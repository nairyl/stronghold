/* tslint:disable */
/* eslint-disable */
/**
 * Rosetta
 * Build Once. Integrate Your Blockchain Everywhere.
 *
 * The version of the OpenAPI document: 1.4.9
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * An AccountBalanceRequest is utilized to make a balance request on the /account/balance endpoint. If the block_identifier is populated, a historical balance query should be performed.
 * @export
 * @interface AccountBalanceRequest
 */
export interface AccountBalanceRequest {
    /**
     * 
     * @type {NetworkIdentifier}
     * @memberof AccountBalanceRequest
     */
    network_identifier: NetworkIdentifier;
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof AccountBalanceRequest
     */
    account_identifier: AccountIdentifier;
    /**
     * 
     * @type {PartialBlockIdentifier}
     * @memberof AccountBalanceRequest
     */
    block_identifier?: PartialBlockIdentifier;
    /**
     * In some cases, the caller may not want to retrieve all available balances for an AccountIdentifier. If the currencies field is populated, only balances for the specified currencies will be returned. If not populated, all available balances will be returned.
     * @type {Array<Currency>}
     * @memberof AccountBalanceRequest
     */
    currencies?: Array<Currency>;
}
/**
 * An AccountBalanceResponse is returned on the /account/balance endpoint. If an account has a balance for each AccountIdentifier describing it (ex: an ERC-20 token balance on a few smart contracts), an account balance request must be made with each AccountIdentifier. The `coins` field was removed and replaced by by `/account/coins` in `v1.4.7`.
 * @export
 * @interface AccountBalanceResponse
 */
export interface AccountBalanceResponse {
    /**
     * 
     * @type {BlockIdentifier}
     * @memberof AccountBalanceResponse
     */
    block_identifier: BlockIdentifier;
    /**
     * A single account may have a balance in multiple currencies.
     * @type {Array<Amount>}
     * @memberof AccountBalanceResponse
     */
    balances: Array<Amount>;
    /**
     * Account-based blockchains that utilize a nonce or sequence number should include that number in the metadata. This number could be unique to the identifier or global across the account address.
     * @type {object}
     * @memberof AccountBalanceResponse
     */
    metadata?: object;
}
/**
 * AccountCoinsRequest is utilized to make a request on the /account/coins endpoint.
 * @export
 * @interface AccountCoinsRequest
 */
export interface AccountCoinsRequest {
    /**
     * 
     * @type {NetworkIdentifier}
     * @memberof AccountCoinsRequest
     */
    network_identifier: NetworkIdentifier;
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof AccountCoinsRequest
     */
    account_identifier: AccountIdentifier;
    /**
     * Include state from the mempool when looking up an account\'s unspent coins. Note, using this functionality breaks any guarantee of idempotency.
     * @type {boolean}
     * @memberof AccountCoinsRequest
     */
    include_mempool: boolean;
    /**
     * In some cases, the caller may not want to retrieve coins for all currencies for an AccountIdentifier. If the currencies field is populated, only coins for the specified currencies will be returned. If not populated, all unspent coins will be returned.
     * @type {Array<Currency>}
     * @memberof AccountCoinsRequest
     */
    currencies?: Array<Currency>;
}
/**
 * AccountCoinsResponse is returned on the /account/coins endpoint and includes all unspent Coins owned by an AccountIdentifier.
 * @export
 * @interface AccountCoinsResponse
 */
export interface AccountCoinsResponse {
    /**
     * 
     * @type {BlockIdentifier}
     * @memberof AccountCoinsResponse
     */
    block_identifier: BlockIdentifier;
    /**
     * If a blockchain is UTXO-based, all unspent Coins owned by an account_identifier should be returned alongside the balance. It is highly recommended to populate this field so that users of the Rosetta API implementation don\'t need to maintain their own indexer to track their UTXOs.
     * @type {Array<Coin>}
     * @memberof AccountCoinsResponse
     */
    coins: Array<Coin>;
    /**
     * Account-based blockchains that utilize a nonce or sequence number should include that number in the metadata. This number could be unique to the identifier or global across the account address.
     * @type {object}
     * @memberof AccountCoinsResponse
     */
    metadata?: object;
}
/**
 * The account_identifier uniquely identifies an account within a network. All fields in the account_identifier are utilized to determine this uniqueness (including the metadata field, if populated).
 * @export
 * @interface AccountIdentifier
 */
export interface AccountIdentifier {
    /**
     * The address may be a cryptographic public key (or some encoding of it) or a provided username.
     * @type {string}
     * @memberof AccountIdentifier
     */
    address: string;
    /**
     * 
     * @type {SubAccountIdentifier}
     * @memberof AccountIdentifier
     */
    sub_account?: SubAccountIdentifier;
    /**
     * Blockchains that utilize a username model (where the address is not a derivative of a cryptographic public key) should specify the public key(s) owned by the address in metadata.
     * @type {object}
     * @memberof AccountIdentifier
     */
    metadata?: object;
}
/**
 * Allow specifies supported Operation status, Operation types, and all possible error statuses. This Allow object is used by clients to validate the correctness of a Rosetta Server implementation. It is expected that these clients will error if they receive some response that contains any of the above information that is not specified here.
 * @export
 * @interface Allow
 */
export interface Allow {
    /**
     * All Operation.Status this implementation supports. Any status that is returned during parsing that is not listed here will cause client validation to error.
     * @type {Array<OperationStatus>}
     * @memberof Allow
     */
    operation_statuses: Array<OperationStatus>;
    /**
     * All Operation.Type this implementation supports. Any type that is returned during parsing that is not listed here will cause client validation to error.
     * @type {Array<string>}
     * @memberof Allow
     */
    operation_types: Array<string>;
    /**
     * All Errors that this implementation could return. Any error that is returned during parsing that is not listed here will cause client validation to error.
     * @type {Array<Error>}
     * @memberof Allow
     */
    errors: Array<Error>;
    /**
     * Any Rosetta implementation that supports querying the balance of an account at any height in the past should set this to true.
     * @type {boolean}
     * @memberof Allow
     */
    historical_balance_lookup: boolean;
    /**
     * If populated, `timestamp_start_index` indicates the first block index where block timestamps are considered valid (i.e. all blocks less than `timestamp_start_index` could have invalid timestamps). This is useful when the genesis block (or blocks) of a network have timestamp 0. If not populated, block timestamps are assumed to be valid for all available blocks.
     * @type {number}
     * @memberof Allow
     */
    timestamp_start_index?: number;
    /**
     * All methods that are supported by the /call endpoint. Communicating which parameters should be provided to /call is the responsibility of the implementer (this is en lieu of defining an entire type system and requiring the implementer to define that in Allow).
     * @type {Array<string>}
     * @memberof Allow
     */
    call_methods: Array<string>;
    /**
     * BalanceExemptions is an array of BalanceExemption indicating which account balances could change without a corresponding Operation. BalanceExemptions should be used sparingly as they may introduce significant complexity for integrators that attempt to reconcile all account balance changes. If your implementation relies on any BalanceExemptions, you MUST implement historical balance lookup (the ability to query an account balance at any BlockIdentifier).
     * @type {Array<BalanceExemption>}
     * @memberof Allow
     */
    balance_exemptions: Array<BalanceExemption>;
    /**
     * Any Rosetta implementation that can update an AccountIdentifier\'s unspent coins based on the contents of the mempool should populate this field as true. If false, requests to `/account/coins` that set `include_mempool` as true will be automatically rejected.
     * @type {boolean}
     * @memberof Allow
     */
    mempool_coins: boolean;
}
/**
 * Amount is some Value of a Currency. It is considered invalid to specify a Value without a Currency.
 * @export
 * @interface Amount
 */
export interface Amount {
    /**
     * Value of the transaction in atomic units represented as an arbitrary-sized signed integer. For example, 1 BTC would be represented by a value of 100000000.
     * @type {string}
     * @memberof Amount
     */
    value: string;
    /**
     * 
     * @type {Currency}
     * @memberof Amount
     */
    currency: Currency;
    /**
     * 
     * @type {object}
     * @memberof Amount
     */
    metadata?: object;
}
/**
 * BalanceExemption indicates that the balance for an exempt account could change without a corresponding Operation. This typically occurs with staking rewards, vesting balances, and Currencies with a dynamic supply. Currently, it is possible to exempt an account from strict reconciliation by SubAccountIdentifier.Address or by Currency. This means that any account with SubAccountIdentifier.Address would be exempt or any balance of a particular Currency would be exempt, respectively. BalanceExemptions should be used sparingly as they may introduce significant complexity for integrators that attempt to reconcile all account balance changes. If your implementation relies on any BalanceExemptions, you MUST implement historical balance lookup (the ability to query an account balance at any BlockIdentifier).
 * @export
 * @interface BalanceExemption
 */
export interface BalanceExemption {
    /**
     * SubAccountAddress is the SubAccountIdentifier.Address that the BalanceExemption applies to (regardless of the value of SubAccountIdentifier.Metadata).
     * @type {string}
     * @memberof BalanceExemption
     */
    sub_account_address?: string;
    /**
     * 
     * @type {Currency}
     * @memberof BalanceExemption
     */
    currency?: Currency;
    /**
     * 
     * @type {ExemptionType}
     * @memberof BalanceExemption
     */
    exemption_type?: ExemptionType;
}
/**
 * Blocks contain an array of Transactions that occurred at a particular BlockIdentifier. A hard requirement for blocks returned by Rosetta implementations is that they MUST be _inalterable_: once a client has requested and received a block identified by a specific BlockIndentifier, all future calls for that same BlockIdentifier must return the same block contents.
 * @export
 * @interface Block
 */
export interface Block {
    /**
     * 
     * @type {BlockIdentifier}
     * @memberof Block
     */
    block_identifier: BlockIdentifier;
    /**
     * 
     * @type {BlockIdentifier}
     * @memberof Block
     */
    parent_block_identifier: BlockIdentifier;
    /**
     * The timestamp of the block in milliseconds since the Unix Epoch. The timestamp is stored in milliseconds because some blockchains produce blocks more often than once a second.
     * @type {number}
     * @memberof Block
     */
    timestamp: number;
    /**
     * 
     * @type {Array<Transaction>}
     * @memberof Block
     */
    transactions: Array<Transaction>;
    /**
     * 
     * @type {object}
     * @memberof Block
     */
    metadata?: object;
}
/**
 * BlockEvent represents the addition or removal of a BlockIdentifier from storage. Streaming BlockEvents allows lightweight clients to update their own state without needing to implement their own syncing logic.
 * @export
 * @interface BlockEvent
 */
export interface BlockEvent {
    /**
     * sequence is the unique identifier of a BlockEvent within the context of a NetworkIdentifier.
     * @type {number}
     * @memberof BlockEvent
     */
    sequence: number;
    /**
     * 
     * @type {BlockIdentifier}
     * @memberof BlockEvent
     */
    block_identifier: BlockIdentifier;
    /**
     * 
     * @type {BlockEventType}
     * @memberof BlockEvent
     */
    type: BlockEventType;
}
/**
 * BlockEventType determines if a BlockEvent represents the addition or removal of a block.
 * @export
 * @enum {string}
 */
export enum BlockEventType {
    Added = 'block_added',
    Removed = 'block_removed'
}

/**
 * The block_identifier uniquely identifies a block in a particular network.
 * @export
 * @interface BlockIdentifier
 */
export interface BlockIdentifier {
    /**
     * This is also known as the block height.
     * @type {number}
     * @memberof BlockIdentifier
     */
    index: number;
    /**
     * 
     * @type {string}
     * @memberof BlockIdentifier
     */
    hash: string;
}
/**
 * A BlockRequest is utilized to make a block request on the /block endpoint.
 * @export
 * @interface BlockRequest
 */
export interface BlockRequest {
    /**
     * 
     * @type {NetworkIdentifier}
     * @memberof BlockRequest
     */
    network_identifier: NetworkIdentifier;
    /**
     * 
     * @type {PartialBlockIdentifier}
     * @memberof BlockRequest
     */
    block_identifier: PartialBlockIdentifier;
}
/**
 * A BlockResponse includes a fully-populated block or a partially-populated block with a list of other transactions to fetch (other_transactions). As a result of the consensus algorithm of some blockchains, blocks can be omitted (i.e. certain block indices can be skipped). If a query for one of these omitted indices is made, the response should not include a `Block` object. It is VERY important to note that blocks MUST still form a canonical, connected chain of blocks where each block has a unique index. In other words, the `PartialBlockIdentifier` of a block after an omitted block should reference the last non-omitted block.
 * @export
 * @interface BlockResponse
 */
export interface BlockResponse {
    /**
     * 
     * @type {Block}
     * @memberof BlockResponse
     */
    block?: Block;
    /**
     * Some blockchains may require additional transactions to be fetched that weren\'t returned in the block response (ex: block only returns transaction hashes). For blockchains with a lot of transactions in each block, this can be very useful as consumers can concurrently fetch all transactions returned.
     * @type {Array<TransactionIdentifier>}
     * @memberof BlockResponse
     */
    other_transactions?: Array<TransactionIdentifier>;
}
/**
 * BlockTransaction contains a populated Transaction and the BlockIdentifier that contains it.
 * @export
 * @interface BlockTransaction
 */
export interface BlockTransaction {
    /**
     * 
     * @type {BlockIdentifier}
     * @memberof BlockTransaction
     */
    block_identifier: BlockIdentifier;
    /**
     * 
     * @type {Transaction}
     * @memberof BlockTransaction
     */
    transaction: Transaction;
}
/**
 * A BlockTransactionRequest is used to fetch a Transaction included in a block that is not returned in a BlockResponse.
 * @export
 * @interface BlockTransactionRequest
 */
export interface BlockTransactionRequest {
    /**
     * 
     * @type {NetworkIdentifier}
     * @memberof BlockTransactionRequest
     */
    network_identifier: NetworkIdentifier;
    /**
     * 
     * @type {BlockIdentifier}
     * @memberof BlockTransactionRequest
     */
    block_identifier: BlockIdentifier;
    /**
     * 
     * @type {TransactionIdentifier}
     * @memberof BlockTransactionRequest
     */
    transaction_identifier: TransactionIdentifier;
}
/**
 * A BlockTransactionResponse contains information about a block transaction.
 * @export
 * @interface BlockTransactionResponse
 */
export interface BlockTransactionResponse {
    /**
     * 
     * @type {Transaction}
     * @memberof BlockTransactionResponse
     */
    transaction: Transaction;
}
/**
 * CallRequest is the input to the `/call` endpoint.
 * @export
 * @interface CallRequest
 */
export interface CallRequest {
    /**
     * 
     * @type {NetworkIdentifier}
     * @memberof CallRequest
     */
    network_identifier: NetworkIdentifier;
    /**
     * Method is some network-specific procedure call. This method could map to a network-specific RPC endpoint, a method in an SDK generated from a smart contract, or some hybrid of the two. The implementation must define all available methods in the Allow object. However, it is up to the caller to determine which parameters to provide when invoking `/call`.
     * @type {string}
     * @memberof CallRequest
     */
    method: string;
    /**
     * Parameters is some network-specific argument for a method. It is up to the caller to determine which parameters to provide when invoking `/call`.
     * @type {object}
     * @memberof CallRequest
     */
    parameters: object;
}
/**
 * CallResponse contains the result of a `/call` invocation.
 * @export
 * @interface CallResponse
 */
export interface CallResponse {
    /**
     * Result contains the result of the `/call` invocation. This result will not be inspected or interpreted by Rosetta tooling and is left to the caller to decode.
     * @type {object}
     * @memberof CallResponse
     */
    result: object;
    /**
     * Idempotent indicates that if `/call` is invoked with the same CallRequest again, at any point in time, it will return the same CallResponse. Integrators may cache the CallResponse if this is set to true to avoid making unnecessary calls to the Rosetta implementation. For this reason, implementers should be very conservative about returning true here or they could cause issues for the caller.
     * @type {boolean}
     * @memberof CallResponse
     */
    idempotent: boolean;
}
/**
 * Coin contains its unique identifier and the amount it represents.
 * @export
 * @interface Coin
 */
export interface Coin {
    /**
     * 
     * @type {CoinIdentifier}
     * @memberof Coin
     */
    coin_identifier: CoinIdentifier;
    /**
     * 
     * @type {Amount}
     * @memberof Coin
     */
    amount: Amount;
}
/**
 * CoinActions are different state changes that a Coin can undergo. When a Coin is created, it is coin_created. When a Coin is spent, it is coin_spent. It is assumed that a single Coin cannot be created or spent more than once.
 * @export
 * @enum {string}
 */
export enum CoinAction {
    Created = 'coin_created',
    Spent = 'coin_spent'
}

/**
 * CoinChange is used to represent a change in state of a some coin identified by a coin_identifier. This object is part of the Operation model and must be populated for UTXO-based blockchains. Coincidentally, this abstraction of UTXOs allows for supporting both account-based transfers and UTXO-based transfers on the same blockchain (when a transfer is account-based, don\'t populate this model).
 * @export
 * @interface CoinChange
 */
export interface CoinChange {
    /**
     * 
     * @type {CoinIdentifier}
     * @memberof CoinChange
     */
    coin_identifier: CoinIdentifier;
    /**
     * 
     * @type {CoinAction}
     * @memberof CoinChange
     */
    coin_action: CoinAction;
}
/**
 * CoinIdentifier uniquely identifies a Coin.
 * @export
 * @interface CoinIdentifier
 */
export interface CoinIdentifier {
    /**
     * Identifier should be populated with a globally unique identifier of a Coin. In Bitcoin, this identifier would be transaction_hash:index.
     * @type {string}
     * @memberof CoinIdentifier
     */
    identifier: string;
}
/**
 * ConstructionCombineRequest is the input to the `/construction/combine` endpoint. It contains the unsigned transaction blob returned by `/construction/payloads` and all required signatures to create a network transaction.
 * @export
 * @interface ConstructionCombineRequest
 */
export interface ConstructionCombineRequest {
    /**
     * 
     * @type {NetworkIdentifier}
     * @memberof ConstructionCombineRequest
     */
    network_identifier: NetworkIdentifier;
    /**
     * 
     * @type {string}
     * @memberof ConstructionCombineRequest
     */
    unsigned_transaction: string;
    /**
     * 
     * @type {Array<Signature>}
     * @memberof ConstructionCombineRequest
     */
    signatures: Array<Signature>;
}
/**
 * ConstructionCombineResponse is returned by `/construction/combine`. The network payload will be sent directly to the `construction/submit` endpoint.
 * @export
 * @interface ConstructionCombineResponse
 */
export interface ConstructionCombineResponse {
    /**
     * 
     * @type {string}
     * @memberof ConstructionCombineResponse
     */
    signed_transaction: string;
}
/**
 * ConstructionDeriveRequest is passed to the `/construction/derive` endpoint. Network is provided in the request because some blockchains have different address formats for different networks. Metadata is provided in the request because some blockchains allow for multiple address types (i.e. different address for validators vs normal accounts).
 * @export
 * @interface ConstructionDeriveRequest
 */
export interface ConstructionDeriveRequest {
    /**
     * 
     * @type {NetworkIdentifier}
     * @memberof ConstructionDeriveRequest
     */
    network_identifier: NetworkIdentifier;
    /**
     * 
     * @type {PublicKey}
     * @memberof ConstructionDeriveRequest
     */
    public_key: PublicKey;
    /**
     * 
     * @type {object}
     * @memberof ConstructionDeriveRequest
     */
    metadata?: object;
}
/**
 * ConstructionDeriveResponse is returned by the `/construction/derive` endpoint.
 * @export
 * @interface ConstructionDeriveResponse
 */
export interface ConstructionDeriveResponse {
    /**
     * [DEPRECATED by `account_identifier` in `v1.4.4`] Address in network-specific format.
     * @type {string}
     * @memberof ConstructionDeriveResponse
     */
    address?: string;
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof ConstructionDeriveResponse
     */
    account_identifier?: AccountIdentifier;
    /**
     * 
     * @type {object}
     * @memberof ConstructionDeriveResponse
     */
    metadata?: object;
}
/**
 * ConstructionHashRequest is the input to the `/construction/hash` endpoint.
 * @export
 * @interface ConstructionHashRequest
 */
export interface ConstructionHashRequest {
    /**
     * 
     * @type {NetworkIdentifier}
     * @memberof ConstructionHashRequest
     */
    network_identifier: NetworkIdentifier;
    /**
     * 
     * @type {string}
     * @memberof ConstructionHashRequest
     */
    signed_transaction: string;
}
/**
 * A ConstructionMetadataRequest is utilized to get information required to construct a transaction. The Options object used to specify which metadata to return is left purposely unstructured to allow flexibility for implementers. Options is not required in the case that there is network-wide metadata of interest. Optionally, the request can also include an array of PublicKeys associated with the AccountIdentifiers returned in ConstructionPreprocessResponse.
 * @export
 * @interface ConstructionMetadataRequest
 */
export interface ConstructionMetadataRequest {
    /**
     * 
     * @type {NetworkIdentifier}
     * @memberof ConstructionMetadataRequest
     */
    network_identifier: NetworkIdentifier;
    /**
     * Some blockchains require different metadata for different types of transaction construction (ex: delegation versus a transfer). Instead of requiring a blockchain node to return all possible types of metadata for construction (which may require multiple node fetches), the client can populate an options object to limit the metadata returned to only the subset required.
     * @type {object}
     * @memberof ConstructionMetadataRequest
     */
    options?: object;
    /**
     * 
     * @type {Array<PublicKey>}
     * @memberof ConstructionMetadataRequest
     */
    public_keys?: Array<PublicKey>;
}
/**
 * The ConstructionMetadataResponse returns network-specific metadata used for transaction construction. Optionally, the implementer can return the suggested fee associated with the transaction being constructed. The caller may use this info to adjust the intent of the transaction or to create a transaction with a different account that can pay the suggested fee. Suggested fee is an array in case fee payment must occur in multiple currencies.
 * @export
 * @interface ConstructionMetadataResponse
 */
export interface ConstructionMetadataResponse {
    /**
     * 
     * @type {object}
     * @memberof ConstructionMetadataResponse
     */
    metadata: object;
    /**
     * 
     * @type {Array<Amount>}
     * @memberof ConstructionMetadataResponse
     */
    suggested_fee?: Array<Amount>;
}
/**
 * ConstructionParseRequest is the input to the `/construction/parse` endpoint. It allows the caller to parse either an unsigned or signed transaction.
 * @export
 * @interface ConstructionParseRequest
 */
export interface ConstructionParseRequest {
    /**
     * 
     * @type {NetworkIdentifier}
     * @memberof ConstructionParseRequest
     */
    network_identifier: NetworkIdentifier;
    /**
     * Signed is a boolean indicating whether the transaction is signed.
     * @type {boolean}
     * @memberof ConstructionParseRequest
     */
    signed: boolean;
    /**
     * This must be either the unsigned transaction blob returned by `/construction/payloads` or the signed transaction blob returned by `/construction/combine`.
     * @type {string}
     * @memberof ConstructionParseRequest
     */
    transaction: string;
}
/**
 * ConstructionParseResponse contains an array of operations that occur in a transaction blob. This should match the array of operations provided to `/construction/preprocess` and `/construction/payloads`.
 * @export
 * @interface ConstructionParseResponse
 */
export interface ConstructionParseResponse {
    /**
     * 
     * @type {Array<Operation>}
     * @memberof ConstructionParseResponse
     */
    operations: Array<Operation>;
    /**
     * [DEPRECATED by `account_identifier_signers` in `v1.4.4`] All signers (addresses) of a particular transaction. If the transaction is unsigned, it should be empty.
     * @type {Array<string>}
     * @memberof ConstructionParseResponse
     */
    signers?: Array<string>;
    /**
     * 
     * @type {Array<AccountIdentifier>}
     * @memberof ConstructionParseResponse
     */
    account_identifier_signers?: Array<AccountIdentifier>;
    /**
     * 
     * @type {object}
     * @memberof ConstructionParseResponse
     */
    metadata?: object;
}
/**
 * ConstructionPayloadsRequest is the request to `/construction/payloads`. It contains the network, a slice of operations, and arbitrary metadata that was returned by the call to `/construction/metadata`. Optionally, the request can also include an array of PublicKeys associated with the AccountIdentifiers returned in ConstructionPreprocessResponse.
 * @export
 * @interface ConstructionPayloadsRequest
 */
export interface ConstructionPayloadsRequest {
    /**
     * 
     * @type {NetworkIdentifier}
     * @memberof ConstructionPayloadsRequest
     */
    network_identifier: NetworkIdentifier;
    /**
     * 
     * @type {Array<Operation>}
     * @memberof ConstructionPayloadsRequest
     */
    operations: Array<Operation>;
    /**
     * 
     * @type {object}
     * @memberof ConstructionPayloadsRequest
     */
    metadata?: object;
    /**
     * 
     * @type {Array<PublicKey>}
     * @memberof ConstructionPayloadsRequest
     */
    public_keys?: Array<PublicKey>;
}
/**
 * ConstructionTransactionResponse is returned by `/construction/payloads`. It contains an unsigned transaction blob (that is usually needed to construct the a network transaction from a collection of signatures) and an array of payloads that must be signed by the caller.
 * @export
 * @interface ConstructionPayloadsResponse
 */
export interface ConstructionPayloadsResponse {
    /**
     * 
     * @type {string}
     * @memberof ConstructionPayloadsResponse
     */
    unsigned_transaction: string;
    /**
     * 
     * @type {Array<SigningPayload>}
     * @memberof ConstructionPayloadsResponse
     */
    payloads: Array<SigningPayload>;
}
/**
 * ConstructionPreprocessRequest is passed to the `/construction/preprocess` endpoint so that a Rosetta implementation can determine which metadata it needs to request for construction. Metadata provided in this object should NEVER be a product of live data (i.e. the caller must follow some network-specific data fetching strategy outside of the Construction API to populate required Metadata). If live data is required for construction, it MUST be fetched in the call to `/construction/metadata`. The caller can provide a max fee they are willing to pay for a transaction. This is an array in the case fees must be paid in multiple currencies. The caller can also provide a suggested fee multiplier to indicate that the suggested fee should be scaled. This may be used to set higher fees for urgent transactions or to pay lower fees when there is less urgency. It is assumed that providing a very low multiplier (like 0.0001) will never lead to a transaction being created with a fee less than the minimum network fee (if applicable). In the case that the caller provides both a max fee and a suggested fee multiplier, the max fee will set an upper bound on the suggested fee (regardless of the multiplier provided).
 * @export
 * @interface ConstructionPreprocessRequest
 */
export interface ConstructionPreprocessRequest {
    /**
     * 
     * @type {NetworkIdentifier}
     * @memberof ConstructionPreprocessRequest
     */
    network_identifier: NetworkIdentifier;
    /**
     * 
     * @type {Array<Operation>}
     * @memberof ConstructionPreprocessRequest
     */
    operations: Array<Operation>;
    /**
     * 
     * @type {object}
     * @memberof ConstructionPreprocessRequest
     */
    metadata?: object;
    /**
     * 
     * @type {Array<Amount>}
     * @memberof ConstructionPreprocessRequest
     */
    max_fee?: Array<Amount>;
    /**
     * 
     * @type {number}
     * @memberof ConstructionPreprocessRequest
     */
    suggested_fee_multiplier?: number;
}
/**
 * ConstructionPreprocessResponse contains `options` that will be sent unmodified to `/construction/metadata`. If it is not necessary to make a request to `/construction/metadata`, `options` should be omitted.  Some blockchains require the PublicKey of particular AccountIdentifiers to construct a valid transaction. To fetch these PublicKeys, populate `required_public_keys` with the AccountIdentifiers associated with the desired PublicKeys. If it is not necessary to retrieve any PublicKeys for construction, `required_public_keys` should be omitted.
 * @export
 * @interface ConstructionPreprocessResponse
 */
export interface ConstructionPreprocessResponse {
    /**
     * The options that will be sent directly to `/construction/metadata` by the caller.
     * @type {object}
     * @memberof ConstructionPreprocessResponse
     */
    options?: object;
    /**
     * 
     * @type {Array<AccountIdentifier>}
     * @memberof ConstructionPreprocessResponse
     */
    required_public_keys?: Array<AccountIdentifier>;
}
/**
 * The transaction submission request includes a signed transaction.
 * @export
 * @interface ConstructionSubmitRequest
 */
export interface ConstructionSubmitRequest {
    /**
     * 
     * @type {NetworkIdentifier}
     * @memberof ConstructionSubmitRequest
     */
    network_identifier: NetworkIdentifier;
    /**
     * 
     * @type {string}
     * @memberof ConstructionSubmitRequest
     */
    signed_transaction: string;
}
/**
 * Currency is composed of a canonical Symbol and Decimals. This Decimals value is used to convert an Amount.Value from atomic units (Satoshis) to standard units (Bitcoins).
 * @export
 * @interface Currency
 */
export interface Currency {
    /**
     * Canonical symbol associated with a currency.
     * @type {string}
     * @memberof Currency
     */
    symbol: string;
    /**
     * Number of decimal places in the standard unit representation of the amount. For example, BTC has 8 decimals. Note that it is not possible to represent the value of some currency in atomic units that is not base 10.
     * @type {number}
     * @memberof Currency
     */
    decimals: number;
    /**
     * Any additional information related to the currency itself. For example, it would be useful to populate this object with the contract address of an ERC-20 token.
     * @type {object}
     * @memberof Currency
     */
    metadata?: object;
}
/**
 * CurveType is the type of cryptographic curve associated with a PublicKey. * secp256k1: SEC compressed - `33 bytes` (https://secg.org/sec1-v2.pdf#subsubsection.2.3.3) * secp256r1: SEC compressed - `33 bytes` (https://secg.org/sec1-v2.pdf#subsubsection.2.3.3) * edwards25519: `y (255-bits) || x-sign-bit (1-bit)` - `32 bytes` (https://ed25519.cr.yp.to/ed25519-20110926.pdf) * tweedle: 1st pk : Fq.t (32 bytes) || 2nd pk : Fq.t (32 bytes) (https://github.com/CodaProtocol/coda/blob/develop/rfcs/0038-rosetta-construction-api.md#marshal-keys)
 * @export
 * @enum {string}
 */
export enum CurveType {
    Secp256k1 = 'secp256k1',
    Secp256r1 = 'secp256r1',
    Edwards25519 = 'edwards25519',
    Tweedle = 'tweedle'
}

/**
 * EventsBlocksRequest is utilized to fetch a sequence of BlockEvents indicating which blocks were added and removed from storage to reach the current state.
 * @export
 * @interface EventsBlocksRequest
 */
export interface EventsBlocksRequest {
    /**
     * 
     * @type {NetworkIdentifier}
     * @memberof EventsBlocksRequest
     */
    network_identifier: NetworkIdentifier;
    /**
     * offset is the offset into the event stream to sync events from. If this field is not populated, we return the limit events backwards from tip. If this is set to 0, we start from the beginning.
     * @type {number}
     * @memberof EventsBlocksRequest
     */
    offset?: number;
    /**
     * limit is the maximum number of events to fetch in one call. The implementation may return <= limit events.
     * @type {number}
     * @memberof EventsBlocksRequest
     */
    limit?: number;
}
/**
 * EventsBlocksResponse contains an ordered collection of BlockEvents and the max retrievable sequence.
 * @export
 * @interface EventsBlocksResponse
 */
export interface EventsBlocksResponse {
    /**
     * max_sequence is the maximum available sequence number to fetch.
     * @type {number}
     * @memberof EventsBlocksResponse
     */
    max_sequence: number;
    /**
     * events is an array of BlockEvents indicating the order to add and remove blocks to maintain a canonical view of blockchain state. Lightweight clients can use this event stream to update state without implementing their own block syncing logic.
     * @type {Array<BlockEvent>}
     * @memberof EventsBlocksResponse
     */
    events: Array<BlockEvent>;
}
/**
 * ExemptionType is used to indicate if the live balance for an account subject to a BalanceExemption could increase above, decrease below, or equal the computed balance. * greater_or_equal: The live balance may increase above or equal the computed balance. This typically   occurs with staking rewards that accrue on each block. * less_or_equal: The live balance may decrease below or equal the computed balance. This typically   occurs as balance moves from locked to spendable on a vesting account. * dynamic: The live balance may increase above, decrease below, or equal the computed balance. This   typically occurs with tokens that have a dynamic supply.
 * @export
 * @enum {string}
 */
export enum ExemptionType {
    GreaterOrEqual = 'greater_or_equal',
    LessOrEqual = 'less_or_equal',
    Dynamic = 'dynamic'
}

/**
 * A MempoolResponse contains all transaction identifiers in the mempool for a particular network_identifier.
 * @export
 * @interface MempoolResponse
 */
export interface MempoolResponse {
    /**
     * 
     * @type {Array<TransactionIdentifier>}
     * @memberof MempoolResponse
     */
    transaction_identifiers: Array<TransactionIdentifier>;
}
/**
 * A MempoolTransactionRequest is utilized to retrieve a transaction from the mempool.
 * @export
 * @interface MempoolTransactionRequest
 */
export interface MempoolTransactionRequest {
    /**
     * 
     * @type {NetworkIdentifier}
     * @memberof MempoolTransactionRequest
     */
    network_identifier: NetworkIdentifier;
    /**
     * 
     * @type {TransactionIdentifier}
     * @memberof MempoolTransactionRequest
     */
    transaction_identifier: TransactionIdentifier;
}
/**
 * A MempoolTransactionResponse contains an estimate of a mempool transaction. It may not be possible to know the full impact of a transaction in the mempool (ex: fee paid).
 * @export
 * @interface MempoolTransactionResponse
 */
export interface MempoolTransactionResponse {
    /**
     * 
     * @type {Transaction}
     * @memberof MempoolTransactionResponse
     */
    transaction: Transaction;
    /**
     * 
     * @type {object}
     * @memberof MempoolTransactionResponse
     */
    metadata?: object;
}
/**
 * A MetadataRequest is utilized in any request where the only argument is optional metadata.
 * @export
 * @interface MetadataRequest
 */
export interface MetadataRequest {
    /**
     * 
     * @type {object}
     * @memberof MetadataRequest
     */
    metadata?: object;
}
/**
 * Instead of utilizing HTTP status codes to describe node errors (which often do not have a good analog), rich errors are returned using this object. Both the code and message fields can be individually used to correctly identify an error. Implementations MUST use unique values for both fields.
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * Code is a network-specific error code. If desired, this code can be equivalent to an HTTP status code.
     * @type {number}
     * @memberof ModelError
     */
    code: number;
    /**
     * Message is a network-specific error message. The message MUST NOT change for a given code. In particular, this means that any contextual information should be included in the details field.
     * @type {string}
     * @memberof ModelError
     */
    message: string;
    /**
     * Description allows the implementer to optionally provide additional information about an error. In many cases, the content of this field will be a copy-and-paste from existing developer documentation. Description can ONLY be populated with generic information about a particular type of error. It MUST NOT be populated with information about a particular instantiation of an error (use `details` for this). Whereas the content of Error.Message should stay stable across releases, the content of Error.Description will likely change across releases (as implementers improve error documentation). For this reason, the content in this field is not part of any type assertion (unlike Error.Message).
     * @type {string}
     * @memberof ModelError
     */
    description?: string;
    /**
     * An error is retriable if the same request may succeed if submitted again.
     * @type {boolean}
     * @memberof ModelError
     */
    retriable: boolean;
    /**
     * Often times it is useful to return context specific to the request that caused the error (i.e. a sample of the stack trace or impacted account) in addition to the standard error message.
     * @type {object}
     * @memberof ModelError
     */
    details?: object;
}
/**
 * The network_identifier specifies which network a particular object is associated with.
 * @export
 * @interface NetworkIdentifier
 */
export interface NetworkIdentifier {
    /**
     * 
     * @type {string}
     * @memberof NetworkIdentifier
     */
    blockchain: string;
    /**
     * If a blockchain has a specific chain-id or network identifier, it should go in this field. It is up to the client to determine which network-specific identifier is mainnet or testnet.
     * @type {string}
     * @memberof NetworkIdentifier
     */
    network: string;
    /**
     * 
     * @type {SubNetworkIdentifier}
     * @memberof NetworkIdentifier
     */
    sub_network_identifier?: SubNetworkIdentifier;
}
/**
 * A NetworkListResponse contains all NetworkIdentifiers that the node can serve information for.
 * @export
 * @interface NetworkListResponse
 */
export interface NetworkListResponse {
    /**
     * 
     * @type {Array<NetworkIdentifier>}
     * @memberof NetworkListResponse
     */
    network_identifiers: Array<NetworkIdentifier>;
}
/**
 * NetworkOptionsResponse contains information about the versioning of the node and the allowed operation statuses, operation types, and errors.
 * @export
 * @interface NetworkOptionsResponse
 */
export interface NetworkOptionsResponse {
    /**
     * 
     * @type {Version}
     * @memberof NetworkOptionsResponse
     */
    version: Version;
    /**
     * 
     * @type {Allow}
     * @memberof NetworkOptionsResponse
     */
    allow: Allow;
}
/**
 * A NetworkRequest is utilized to retrieve some data specific exclusively to a NetworkIdentifier.
 * @export
 * @interface NetworkRequest
 */
export interface NetworkRequest {
    /**
     * 
     * @type {NetworkIdentifier}
     * @memberof NetworkRequest
     */
    network_identifier: NetworkIdentifier;
    /**
     * 
     * @type {object}
     * @memberof NetworkRequest
     */
    metadata?: object;
}
/**
 * NetworkStatusResponse contains basic information about the node\'s view of a blockchain network. It is assumed that any BlockIdentifier.Index less than or equal to CurrentBlockIdentifier.Index can be queried. If a Rosetta implementation prunes historical state, it should populate the optional `oldest_block_identifier` field with the oldest block available to query. If this is not populated, it is assumed that the `genesis_block_identifier` is the oldest queryable block. If a Rosetta implementation performs some pre-sync before it is possible to query blocks, sync_status should be populated so that clients can still monitor healthiness. Without this field, it may appear that the implementation is stuck syncing and needs to be terminated.
 * @export
 * @interface NetworkStatusResponse
 */
export interface NetworkStatusResponse {
    /**
     * 
     * @type {BlockIdentifier}
     * @memberof NetworkStatusResponse
     */
    current_block_identifier: BlockIdentifier;
    /**
     * The timestamp of the block in milliseconds since the Unix Epoch. The timestamp is stored in milliseconds because some blockchains produce blocks more often than once a second.
     * @type {number}
     * @memberof NetworkStatusResponse
     */
    current_block_timestamp: number;
    /**
     * 
     * @type {BlockIdentifier}
     * @memberof NetworkStatusResponse
     */
    genesis_block_identifier: BlockIdentifier;
    /**
     * 
     * @type {BlockIdentifier}
     * @memberof NetworkStatusResponse
     */
    oldest_block_identifier?: BlockIdentifier;
    /**
     * 
     * @type {SyncStatus}
     * @memberof NetworkStatusResponse
     */
    sync_status?: SyncStatus;
    /**
     * 
     * @type {Array<Peer>}
     * @memberof NetworkStatusResponse
     */
    peers: Array<Peer>;
}
/**
 * Operations contain all balance-changing information within a transaction. They are always one-sided (only affect 1 AccountIdentifier) and can succeed or fail independently from a Transaction. Operations are used both to represent on-chain data (Data API) and to construct new transactions (Construction API), creating a standard interface for reading and writing to blockchains.
 * @export
 * @interface Operation
 */
export interface Operation {
    /**
     * 
     * @type {OperationIdentifier}
     * @memberof Operation
     */
    operation_identifier: OperationIdentifier;
    /**
     * Restrict referenced related_operations to identifier indices < the current operation_identifier.index. This ensures there exists a clear DAG-structure of relations. Since operations are one-sided, one could imagine relating operations in a single transfer or linking operations in a call tree.
     * @type {Array<OperationIdentifier>}
     * @memberof Operation
     */
    related_operations?: Array<OperationIdentifier>;
    /**
     * Type is the network-specific type of the operation. Ensure that any type that can be returned here is also specified in the NetworkOptionsResponse. This can be very useful to downstream consumers that parse all block data.
     * @type {string}
     * @memberof Operation
     */
    type: string;
    /**
     * Status is the network-specific status of the operation. Status is not defined on the transaction object because blockchains with smart contracts may have transactions that partially apply (some operations are successful and some are not). Blockchains with atomic transactions (all operations succeed or all operations fail) will have the same status for each operation. On-chain operations (operations retrieved in the `/block` and `/block/transaction` endpoints) MUST have a populated status field (anything on-chain must have succeeded or failed). However, operations provided during transaction construction (often times called \"intent\" in the documentation) MUST NOT have a populated status field (operations yet to be included on-chain have not yet succeeded or failed).
     * @type {string}
     * @memberof Operation
     */
    status?: string;
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof Operation
     */
    account?: AccountIdentifier;
    /**
     * 
     * @type {Amount}
     * @memberof Operation
     */
    amount?: Amount;
    /**
     * 
     * @type {CoinChange}
     * @memberof Operation
     */
    coin_change?: CoinChange;
    /**
     * 
     * @type {object}
     * @memberof Operation
     */
    metadata?: object;
}
/**
 * The operation_identifier uniquely identifies an operation within a transaction.
 * @export
 * @interface OperationIdentifier
 */
export interface OperationIdentifier {
    /**
     * The operation index is used to ensure each operation has a unique identifier within a transaction. This index is only relative to the transaction and NOT GLOBAL. The operations in each transaction should start from index 0. To clarify, there may not be any notion of an operation index in the blockchain being described.
     * @type {number}
     * @memberof OperationIdentifier
     */
    index: number;
    /**
     * Some blockchains specify an operation index that is essential for client use. For example, Bitcoin uses a network_index to identify which UTXO was used in a transaction. network_index should not be populated if there is no notion of an operation index in a blockchain (typically most account-based blockchains).
     * @type {number}
     * @memberof OperationIdentifier
     */
    network_index?: number;
}
/**
 * OperationStatus is utilized to indicate which Operation status are considered successful.
 * @export
 * @interface OperationStatus
 */
export interface OperationStatus {
    /**
     * The status is the network-specific status of the operation.
     * @type {string}
     * @memberof OperationStatus
     */
    status: string;
    /**
     * An Operation is considered successful if the Operation.Amount should affect the Operation.Account. Some blockchains (like Bitcoin) only include successful operations in blocks but other blockchains (like Ethereum) include unsuccessful operations that incur a fee. To reconcile the computed balance from the stream of Operations, it is critical to understand which Operation.Status indicate an Operation is successful and should affect an Account.
     * @type {boolean}
     * @memberof OperationStatus
     */
    successful: boolean;
}
/**
 * Operator is used by query-related endpoints to determine how to apply conditions. If this field is not populated, the default `and` value will be used.
 * @export
 * @enum {string}
 */
export enum Operator {
    Or = 'or',
    And = 'and'
}

/**
 * When fetching data by BlockIdentifier, it may be possible to only specify the index or hash. If neither property is specified, it is assumed that the client is making a request at the current block.
 * @export
 * @interface PartialBlockIdentifier
 */
export interface PartialBlockIdentifier {
    /**
     * 
     * @type {number}
     * @memberof PartialBlockIdentifier
     */
    index?: number;
    /**
     * 
     * @type {string}
     * @memberof PartialBlockIdentifier
     */
    hash?: string;
}
/**
 * A Peer is a representation of a node\'s peer.
 * @export
 * @interface Peer
 */
export interface Peer {
    /**
     * 
     * @type {string}
     * @memberof Peer
     */
    peer_id: string;
    /**
     * 
     * @type {object}
     * @memberof Peer
     */
    metadata?: object;
}
/**
 * PublicKey contains a public key byte array for a particular CurveType encoded in hex. Note that there is no PrivateKey struct as this is NEVER the concern of an implementation.
 * @export
 * @interface PublicKey
 */
export interface PublicKey {
    /**
     * Hex-encoded public key bytes in the format specified by the CurveType.
     * @type {string}
     * @memberof PublicKey
     */
    hex_bytes: string;
    /**
     * 
     * @type {CurveType}
     * @memberof PublicKey
     */
    curve_type: CurveType;
}
/**
 * SearchTransactionsRequest is used to search for transactions matching a set of provided conditions in canonical blocks.
 * @export
 * @interface SearchTransactionsRequest
 */
export interface SearchTransactionsRequest {
    /**
     * 
     * @type {NetworkIdentifier}
     * @memberof SearchTransactionsRequest
     */
    network_identifier: NetworkIdentifier;
    /**
     * 
     * @type {Operator}
     * @memberof SearchTransactionsRequest
     */
    operator?: Operator;
    /**
     * max_block is the largest block index to consider when searching for transactions. If this field is not populated, the current block is considered the max_block. If you do not specify a max_block, it is possible a newly synced block will interfere with paginated transaction queries (as the offset could become invalid with newly added rows).
     * @type {number}
     * @memberof SearchTransactionsRequest
     */
    max_block?: number;
    /**
     * offset is the offset into the query result to start returning transactions. If any search conditions are changed, the query offset will change and you must restart your search iteration.
     * @type {number}
     * @memberof SearchTransactionsRequest
     */
    offset?: number;
    /**
     * limit is the maximum number of transactions to return in one call. The implementation may return <= limit transactions.
     * @type {number}
     * @memberof SearchTransactionsRequest
     */
    limit?: number;
    /**
     * 
     * @type {TransactionIdentifier}
     * @memberof SearchTransactionsRequest
     */
    transaction_identifier?: TransactionIdentifier;
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof SearchTransactionsRequest
     */
    account_identifier?: AccountIdentifier;
    /**
     * 
     * @type {CoinIdentifier}
     * @memberof SearchTransactionsRequest
     */
    coin_identifier?: CoinIdentifier;
    /**
     * 
     * @type {Currency}
     * @memberof SearchTransactionsRequest
     */
    currency?: Currency;
    /**
     * status is the network-specific operation type.
     * @type {string}
     * @memberof SearchTransactionsRequest
     */
    status?: string;
    /**
     * type is the network-specific operation type.
     * @type {string}
     * @memberof SearchTransactionsRequest
     */
    type?: string;
    /**
     * address is AccountIdentifier.Address. This is used to get all transactions related to an AccountIdentifier.Address, regardless of SubAccountIdentifier.
     * @type {string}
     * @memberof SearchTransactionsRequest
     */
    address?: string;
    /**
     * success is a synthetic condition populated by parsing network-specific operation statuses (using the mapping provided in `/network/options`).
     * @type {boolean}
     * @memberof SearchTransactionsRequest
     */
    success?: boolean;
}
/**
 * SearchTransactionsResponse contains an ordered collection of BlockTransactions that match the query in SearchTransactionsRequest. These BlockTransactions are sorted from most recent block to oldest block.
 * @export
 * @interface SearchTransactionsResponse
 */
export interface SearchTransactionsResponse {
    /**
     * transactions is an array of BlockTransactions sorted by most recent BlockIdentifier (meaning that transactions in recent blocks appear first). If there are many transactions for a particular search, transactions may not contain all matching transactions. It is up to the caller to paginate these transactions using the max_block field.
     * @type {Array<BlockTransaction>}
     * @memberof SearchTransactionsResponse
     */
    transactions: Array<BlockTransaction>;
    /**
     * total_count is the number of results for a given search. Callers typically use this value to concurrently fetch results by offset or to display a virtual page number associated with results.
     * @type {number}
     * @memberof SearchTransactionsResponse
     */
    total_count: number;
    /**
     * next_offset is the next offset to use when paginating through transaction results. If this field is not populated, there are no more transactions to query.
     * @type {number}
     * @memberof SearchTransactionsResponse
     */
    next_offset?: number;
}
/**
 * Signature contains the payload that was signed, the public keys of the keypairs used to produce the signature, the signature (encoded in hex), and the SignatureType. PublicKey is often times not known during construction of the signing payloads but may be needed to combine signatures properly.
 * @export
 * @interface Signature
 */
export interface Signature {
    /**
     * 
     * @type {SigningPayload}
     * @memberof Signature
     */
    signing_payload: SigningPayload;
    /**
     * 
     * @type {PublicKey}
     * @memberof Signature
     */
    public_key: PublicKey;
    /**
     * 
     * @type {SignatureType}
     * @memberof Signature
     */
    signature_type: SignatureType;
    /**
     * 
     * @type {string}
     * @memberof Signature
     */
    hex_bytes: string;
}
/**
 * SignatureType is the type of a cryptographic signature. * ecdsa: `r (32-bytes) || s (32-bytes)` - `64 bytes` * ecdsa_recovery: `r (32-bytes) || s (32-bytes) || v (1-byte)` - `65 bytes` * ed25519: `R (32-byte) || s (32-bytes)` - `64 bytes` * schnorr_1: `r (32-bytes) || s (32-bytes)` - `64 bytes`  (schnorr signature implemented by Zilliqa where both `r` and `s` are scalars encoded as `32-bytes` values, most significant byte first.) * schnorr_poseidon: `r (32-bytes) || s (32-bytes)` where s = Hash(1st pk || 2nd pk || r) - `64 bytes`  (schnorr signature w/ Poseidon hash function implemented by O(1) Labs where both `r` and `s` are scalars encoded as `32-bytes` values, least significant byte first. https://github.com/CodaProtocol/signer-reference/blob/master/schnorr.ml )
 * @export
 * @enum {string}
 */
export enum SignatureType {
    Ecdsa = 'ecdsa',
    EcdsaRecovery = 'ecdsa_recovery',
    Ed25519 = 'ed25519',
    Schnorr1 = 'schnorr_1',
    SchnorrPoseidon = 'schnorr_poseidon'
}

/**
 * SigningPayload is signed by the client with the keypair associated with an AccountIdentifier using the specified SignatureType. SignatureType can be optionally populated if there is a restriction on the signature scheme that can be used to sign the payload.
 * @export
 * @interface SigningPayload
 */
export interface SigningPayload {
    /**
     * [DEPRECATED by `account_identifier` in `v1.4.4`] The network-specific address of the account that should sign the payload.
     * @type {string}
     * @memberof SigningPayload
     */
    address?: string;
    /**
     * 
     * @type {AccountIdentifier}
     * @memberof SigningPayload
     */
    account_identifier?: AccountIdentifier;
    /**
     * 
     * @type {string}
     * @memberof SigningPayload
     */
    hex_bytes: string;
    /**
     * 
     * @type {SignatureType}
     * @memberof SigningPayload
     */
    signature_type?: SignatureType;
}
/**
 * An account may have state specific to a contract address (ERC-20 token) and/or a stake (delegated balance). The sub_account_identifier should specify which state (if applicable) an account instantiation refers to.
 * @export
 * @interface SubAccountIdentifier
 */
export interface SubAccountIdentifier {
    /**
     * The SubAccount address may be a cryptographic value or some other identifier (ex: bonded) that uniquely specifies a SubAccount.
     * @type {string}
     * @memberof SubAccountIdentifier
     */
    address: string;
    /**
     * If the SubAccount address is not sufficient to uniquely specify a SubAccount, any other identifying information can be stored here. It is important to note that two SubAccounts with identical addresses but differing metadata will not be considered equal by clients.
     * @type {object}
     * @memberof SubAccountIdentifier
     */
    metadata?: object;
}
/**
 * In blockchains with sharded state, the SubNetworkIdentifier is required to query some object on a specific shard. This identifier is optional for all non-sharded blockchains.
 * @export
 * @interface SubNetworkIdentifier
 */
export interface SubNetworkIdentifier {
    /**
     * 
     * @type {string}
     * @memberof SubNetworkIdentifier
     */
    network: string;
    /**
     * 
     * @type {object}
     * @memberof SubNetworkIdentifier
     */
    metadata?: object;
}
/**
 * SyncStatus is used to provide additional context about an implementation\'s sync status. This object is often used by implementations to indicate healthiness when block data cannot be queried until some sync phase completes or cannot be determined by comparing the timestamp of the most recent block with the current time.
 * @export
 * @interface SyncStatus
 */
export interface SyncStatus {
    /**
     * CurrentIndex is the index of the last synced block in the current stage. This is a separate field from current_block_identifier in NetworkStatusResponse because blocks with indices up to and including the current_index may not yet be queryable by the caller. To reiterate, all indices up to and including current_block_identifier in NetworkStatusResponse must be queryable via the /block endpoint (excluding indices less than oldest_block_identifier).
     * @type {number}
     * @memberof SyncStatus
     */
    current_index?: number;
    /**
     * TargetIndex is the index of the block that the implementation is attempting to sync to in the current stage.
     * @type {number}
     * @memberof SyncStatus
     */
    target_index?: number;
    /**
     * Stage is the phase of the sync process.
     * @type {string}
     * @memberof SyncStatus
     */
    stage?: string;
    /**
     * sycned is a boolean that indicates if an implementation has synced up to the most recent block. If this field is not populated, the caller should rely on a traditional tip timestamp comparison to determine if an implementation is synced. This field is particularly useful for quiescent blockchains (blocks only produced when there are pending transactions). In these blockchains, the most recent block could have a timestamp far behind the current time but the node could be healthy and at tip.
     * @type {boolean}
     * @memberof SyncStatus
     */
    synced?: boolean;
}
/**
 * Transactions contain an array of Operations that are attributable to the same TransactionIdentifier.
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * 
     * @type {TransactionIdentifier}
     * @memberof Transaction
     */
    transaction_identifier: TransactionIdentifier;
    /**
     * 
     * @type {Array<Operation>}
     * @memberof Transaction
     */
    operations: Array<Operation>;
    /**
     * Transactions that are related to other transactions (like a cross-shard transaction) should include the tranaction_identifier of these transactions in the metadata.
     * @type {object}
     * @memberof Transaction
     */
    metadata?: object;
}
/**
 * The transaction_identifier uniquely identifies a transaction in a particular network and block or in the mempool.
 * @export
 * @interface TransactionIdentifier
 */
export interface TransactionIdentifier {
    /**
     * Any transactions that are attributable only to a block (ex: a block event) should use the hash of the block as the identifier.
     * @type {string}
     * @memberof TransactionIdentifier
     */
    hash: string;
}
/**
 * TransactionIdentifierResponse contains the transaction_identifier of a transaction that was submitted to either `/construction/hash` or `/construction/submit`.
 * @export
 * @interface TransactionIdentifierResponse
 */
export interface TransactionIdentifierResponse {
    /**
     * 
     * @type {TransactionIdentifier}
     * @memberof TransactionIdentifierResponse
     */
    transaction_identifier: TransactionIdentifier;
    /**
     * 
     * @type {object}
     * @memberof TransactionIdentifierResponse
     */
    metadata?: object;
}
/**
 * The Version object is utilized to inform the client of the versions of different components of the Rosetta implementation.
 * @export
 * @interface Version
 */
export interface Version {
    /**
     * The rosetta_version is the version of the Rosetta interface the implementation adheres to. This can be useful for clients looking to reliably parse responses.
     * @type {string}
     * @memberof Version
     */
    rosetta_version: string;
    /**
     * The node_version is the canonical version of the node runtime. This can help clients manage deployments.
     * @type {string}
     * @memberof Version
     */
    node_version: string;
    /**
     * When a middleware server is used to adhere to the Rosetta interface, it should return its version here. This can help clients manage deployments.
     * @type {string}
     * @memberof Version
     */
    middleware_version?: string;
    /**
     * Any other information that may be useful about versioning of dependent services should be returned here.
     * @type {object}
     * @memberof Version
     */
    metadata?: object;
}

/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get an array of all AccountBalances for an AccountIdentifier and the BlockIdentifier at which the balance lookup was performed. The BlockIdentifier must always be returned because some consumers of account balance data need to know specifically at which block the balance was calculated to compare balances they compute from operations with the balance returned by the node. It is important to note that making a balance request for an account without populating the SubAccountIdentifier should not result in the balance of all possible SubAccountIdentifiers being returned. Rather, it should result in the balance pertaining to no SubAccountIdentifiers being returned (sometimes called the liquid balance). To get all balances associated with an account, it may be necessary to perform multiple balance requests with unique AccountIdentifiers. It is also possible to perform a historical balance lookup (if the server supports it) by passing in an optional BlockIdentifier.
         * @summary Get an Account\'s Balance
         * @param {AccountBalanceRequest} accountBalanceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountBalance: async (accountBalanceRequest: AccountBalanceRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountBalanceRequest' is not null or undefined
            if (accountBalanceRequest === null || accountBalanceRequest === undefined) {
                throw new RequiredError('accountBalanceRequest','Required parameter accountBalanceRequest was null or undefined when calling accountBalance.');
            }
            const localVarPath = `/account/balance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof accountBalanceRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(accountBalanceRequest !== undefined ? accountBalanceRequest : {})
                : (accountBalanceRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an array of all unspent coins for an AccountIdentifier and the BlockIdentifier at which the lookup was performed. If your implementation does not support coins (i.e. it is for an account-based blockchain), you do not need to implement this endpoint. If you implementation does support coins (i.e. it is fro a UTXO-based blockchain), you MUST also complete the `/account/balance` endpoint. It is important to note that making a coins request for an account without populating the SubAccountIdentifier should not result in the coins of all possible SubAccountIdentifiers being returned. Rather, it should result in the coins pertaining to no SubAccountIdentifiers being returned. To get all coins associated with an account, it may be necessary to perform multiple coin requests with unique AccountIdentifiers. Optionally, an implementation may choose to support updating an AccountIdentifier\'s unspent coins based on the contents of the mempool. Note, using this functionality breaks any guarantee of idempotency.
         * @summary Get an Account\'s Unspent Coins
         * @param {AccountCoinsRequest} accountCoinsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountCoins: async (accountCoinsRequest: AccountCoinsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountCoinsRequest' is not null or undefined
            if (accountCoinsRequest === null || accountCoinsRequest === undefined) {
                throw new RequiredError('accountCoinsRequest','Required parameter accountCoinsRequest was null or undefined when calling accountCoins.');
            }
            const localVarPath = `/account/coins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof accountCoinsRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(accountCoinsRequest !== undefined ? accountCoinsRequest : {})
                : (accountCoinsRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get an array of all AccountBalances for an AccountIdentifier and the BlockIdentifier at which the balance lookup was performed. The BlockIdentifier must always be returned because some consumers of account balance data need to know specifically at which block the balance was calculated to compare balances they compute from operations with the balance returned by the node. It is important to note that making a balance request for an account without populating the SubAccountIdentifier should not result in the balance of all possible SubAccountIdentifiers being returned. Rather, it should result in the balance pertaining to no SubAccountIdentifiers being returned (sometimes called the liquid balance). To get all balances associated with an account, it may be necessary to perform multiple balance requests with unique AccountIdentifiers. It is also possible to perform a historical balance lookup (if the server supports it) by passing in an optional BlockIdentifier.
         * @summary Get an Account\'s Balance
         * @param {AccountBalanceRequest} accountBalanceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountBalance(accountBalanceRequest: AccountBalanceRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountBalanceResponse>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).accountBalance(accountBalanceRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get an array of all unspent coins for an AccountIdentifier and the BlockIdentifier at which the lookup was performed. If your implementation does not support coins (i.e. it is for an account-based blockchain), you do not need to implement this endpoint. If you implementation does support coins (i.e. it is fro a UTXO-based blockchain), you MUST also complete the `/account/balance` endpoint. It is important to note that making a coins request for an account without populating the SubAccountIdentifier should not result in the coins of all possible SubAccountIdentifiers being returned. Rather, it should result in the coins pertaining to no SubAccountIdentifiers being returned. To get all coins associated with an account, it may be necessary to perform multiple coin requests with unique AccountIdentifiers. Optionally, an implementation may choose to support updating an AccountIdentifier\'s unspent coins based on the contents of the mempool. Note, using this functionality breaks any guarantee of idempotency.
         * @summary Get an Account\'s Unspent Coins
         * @param {AccountCoinsRequest} accountCoinsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountCoins(accountCoinsRequest: AccountCoinsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountCoinsResponse>> {
            const localVarAxiosArgs = await AccountApiAxiosParamCreator(configuration).accountCoins(accountCoinsRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get an array of all AccountBalances for an AccountIdentifier and the BlockIdentifier at which the balance lookup was performed. The BlockIdentifier must always be returned because some consumers of account balance data need to know specifically at which block the balance was calculated to compare balances they compute from operations with the balance returned by the node. It is important to note that making a balance request for an account without populating the SubAccountIdentifier should not result in the balance of all possible SubAccountIdentifiers being returned. Rather, it should result in the balance pertaining to no SubAccountIdentifiers being returned (sometimes called the liquid balance). To get all balances associated with an account, it may be necessary to perform multiple balance requests with unique AccountIdentifiers. It is also possible to perform a historical balance lookup (if the server supports it) by passing in an optional BlockIdentifier.
         * @summary Get an Account\'s Balance
         * @param {AccountBalanceRequest} accountBalanceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountBalance(accountBalanceRequest: AccountBalanceRequest, options?: any): AxiosPromise<AccountBalanceResponse> {
            return AccountApiFp(configuration).accountBalance(accountBalanceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an array of all unspent coins for an AccountIdentifier and the BlockIdentifier at which the lookup was performed. If your implementation does not support coins (i.e. it is for an account-based blockchain), you do not need to implement this endpoint. If you implementation does support coins (i.e. it is fro a UTXO-based blockchain), you MUST also complete the `/account/balance` endpoint. It is important to note that making a coins request for an account without populating the SubAccountIdentifier should not result in the coins of all possible SubAccountIdentifiers being returned. Rather, it should result in the coins pertaining to no SubAccountIdentifiers being returned. To get all coins associated with an account, it may be necessary to perform multiple coin requests with unique AccountIdentifiers. Optionally, an implementation may choose to support updating an AccountIdentifier\'s unspent coins based on the contents of the mempool. Note, using this functionality breaks any guarantee of idempotency.
         * @summary Get an Account\'s Unspent Coins
         * @param {AccountCoinsRequest} accountCoinsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountCoins(accountCoinsRequest: AccountCoinsRequest, options?: any): AxiosPromise<AccountCoinsResponse> {
            return AccountApiFp(configuration).accountCoins(accountCoinsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
    /**
     * Get an array of all AccountBalances for an AccountIdentifier and the BlockIdentifier at which the balance lookup was performed. The BlockIdentifier must always be returned because some consumers of account balance data need to know specifically at which block the balance was calculated to compare balances they compute from operations with the balance returned by the node. It is important to note that making a balance request for an account without populating the SubAccountIdentifier should not result in the balance of all possible SubAccountIdentifiers being returned. Rather, it should result in the balance pertaining to no SubAccountIdentifiers being returned (sometimes called the liquid balance). To get all balances associated with an account, it may be necessary to perform multiple balance requests with unique AccountIdentifiers. It is also possible to perform a historical balance lookup (if the server supports it) by passing in an optional BlockIdentifier.
     * @summary Get an Account\'s Balance
     * @param {AccountBalanceRequest} accountBalanceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountBalance(accountBalanceRequest: AccountBalanceRequest, options?: any) {
        return AccountApiFp(this.configuration).accountBalance(accountBalanceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an array of all unspent coins for an AccountIdentifier and the BlockIdentifier at which the lookup was performed. If your implementation does not support coins (i.e. it is for an account-based blockchain), you do not need to implement this endpoint. If you implementation does support coins (i.e. it is fro a UTXO-based blockchain), you MUST also complete the `/account/balance` endpoint. It is important to note that making a coins request for an account without populating the SubAccountIdentifier should not result in the coins of all possible SubAccountIdentifiers being returned. Rather, it should result in the coins pertaining to no SubAccountIdentifiers being returned. To get all coins associated with an account, it may be necessary to perform multiple coin requests with unique AccountIdentifiers. Optionally, an implementation may choose to support updating an AccountIdentifier\'s unspent coins based on the contents of the mempool. Note, using this functionality breaks any guarantee of idempotency.
     * @summary Get an Account\'s Unspent Coins
     * @param {AccountCoinsRequest} accountCoinsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public accountCoins(accountCoinsRequest: AccountCoinsRequest, options?: any) {
        return AccountApiFp(this.configuration).accountCoins(accountCoinsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BlockApi - axios parameter creator
 * @export
 */
export const BlockApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a block by its Block Identifier. If transactions are returned in the same call to the node as fetching the block, the response should include these transactions in the Block object. If not, an array of Transaction Identifiers should be returned so /block/transaction fetches can be done to get all transaction information. When requesting a block by the hash component of the BlockIdentifier, this request MUST be idempotent: repeated invocations for the same hash-identified block must return the exact same block contents. No such restriction is imposed when requesting a block by height, given that a chain reorg event might cause the specific block at height `n` to be set to a different one.
         * @summary Get a Block
         * @param {BlockRequest} blockRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        block: async (blockRequest: BlockRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockRequest' is not null or undefined
            if (blockRequest === null || blockRequest === undefined) {
                throw new RequiredError('blockRequest','Required parameter blockRequest was null or undefined when calling block.');
            }
            const localVarPath = `/block`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof blockRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(blockRequest !== undefined ? blockRequest : {})
                : (blockRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a transaction in a block by its Transaction Identifier. This endpoint should only be used when querying a node for a block does not return all transactions contained within it. All transactions returned by this endpoint must be appended to any transactions returned by the /block method by consumers of this data. Fetching a transaction by hash is considered an Explorer Method (which is classified under the Future Work section). This method can be used to let consumers to paginate results when the  block trasactions count is too big to be returned in a single BlockResponse. Calling this endpoint requires reference to a BlockIdentifier because transaction parsing can change depending on which block contains the transaction. For example, in Bitcoin it is necessary to know which block contains a transaction to determine the destination of fee payments. Without specifying a block identifier, the node would have to infer which block to use (which could change during a re-org). Implementations that require fetching previous transactions to populate the response (ex: Previous UTXOs in Bitcoin) may find it useful to run a cache within the Rosetta server in the /data directory (on a path that does not conflict with the node).
         * @summary Get a Block Transaction
         * @param {BlockTransactionRequest} blockTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockTransaction: async (blockTransactionRequest: BlockTransactionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'blockTransactionRequest' is not null or undefined
            if (blockTransactionRequest === null || blockTransactionRequest === undefined) {
                throw new RequiredError('blockTransactionRequest','Required parameter blockTransactionRequest was null or undefined when calling blockTransaction.');
            }
            const localVarPath = `/block/transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof blockTransactionRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(blockTransactionRequest !== undefined ? blockTransactionRequest : {})
                : (blockTransactionRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BlockApi - functional programming interface
 * @export
 */
export const BlockApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get a block by its Block Identifier. If transactions are returned in the same call to the node as fetching the block, the response should include these transactions in the Block object. If not, an array of Transaction Identifiers should be returned so /block/transaction fetches can be done to get all transaction information. When requesting a block by the hash component of the BlockIdentifier, this request MUST be idempotent: repeated invocations for the same hash-identified block must return the exact same block contents. No such restriction is imposed when requesting a block by height, given that a chain reorg event might cause the specific block at height `n` to be set to a different one.
         * @summary Get a Block
         * @param {BlockRequest} blockRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async block(blockRequest: BlockRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlockResponse>> {
            const localVarAxiosArgs = await BlockApiAxiosParamCreator(configuration).block(blockRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a transaction in a block by its Transaction Identifier. This endpoint should only be used when querying a node for a block does not return all transactions contained within it. All transactions returned by this endpoint must be appended to any transactions returned by the /block method by consumers of this data. Fetching a transaction by hash is considered an Explorer Method (which is classified under the Future Work section). This method can be used to let consumers to paginate results when the  block trasactions count is too big to be returned in a single BlockResponse. Calling this endpoint requires reference to a BlockIdentifier because transaction parsing can change depending on which block contains the transaction. For example, in Bitcoin it is necessary to know which block contains a transaction to determine the destination of fee payments. Without specifying a block identifier, the node would have to infer which block to use (which could change during a re-org). Implementations that require fetching previous transactions to populate the response (ex: Previous UTXOs in Bitcoin) may find it useful to run a cache within the Rosetta server in the /data directory (on a path that does not conflict with the node).
         * @summary Get a Block Transaction
         * @param {BlockTransactionRequest} blockTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async blockTransaction(blockTransactionRequest: BlockTransactionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BlockTransactionResponse>> {
            const localVarAxiosArgs = await BlockApiAxiosParamCreator(configuration).blockTransaction(blockTransactionRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * BlockApi - factory interface
 * @export
 */
export const BlockApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get a block by its Block Identifier. If transactions are returned in the same call to the node as fetching the block, the response should include these transactions in the Block object. If not, an array of Transaction Identifiers should be returned so /block/transaction fetches can be done to get all transaction information. When requesting a block by the hash component of the BlockIdentifier, this request MUST be idempotent: repeated invocations for the same hash-identified block must return the exact same block contents. No such restriction is imposed when requesting a block by height, given that a chain reorg event might cause the specific block at height `n` to be set to a different one.
         * @summary Get a Block
         * @param {BlockRequest} blockRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        block(blockRequest: BlockRequest, options?: any): AxiosPromise<BlockResponse> {
            return BlockApiFp(configuration).block(blockRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a transaction in a block by its Transaction Identifier. This endpoint should only be used when querying a node for a block does not return all transactions contained within it. All transactions returned by this endpoint must be appended to any transactions returned by the /block method by consumers of this data. Fetching a transaction by hash is considered an Explorer Method (which is classified under the Future Work section). This method can be used to let consumers to paginate results when the  block trasactions count is too big to be returned in a single BlockResponse. Calling this endpoint requires reference to a BlockIdentifier because transaction parsing can change depending on which block contains the transaction. For example, in Bitcoin it is necessary to know which block contains a transaction to determine the destination of fee payments. Without specifying a block identifier, the node would have to infer which block to use (which could change during a re-org). Implementations that require fetching previous transactions to populate the response (ex: Previous UTXOs in Bitcoin) may find it useful to run a cache within the Rosetta server in the /data directory (on a path that does not conflict with the node).
         * @summary Get a Block Transaction
         * @param {BlockTransactionRequest} blockTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        blockTransaction(blockTransactionRequest: BlockTransactionRequest, options?: any): AxiosPromise<BlockTransactionResponse> {
            return BlockApiFp(configuration).blockTransaction(blockTransactionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BlockApi - object-oriented interface
 * @export
 * @class BlockApi
 * @extends {BaseAPI}
 */
export class BlockApi extends BaseAPI {
    /**
     * Get a block by its Block Identifier. If transactions are returned in the same call to the node as fetching the block, the response should include these transactions in the Block object. If not, an array of Transaction Identifiers should be returned so /block/transaction fetches can be done to get all transaction information. When requesting a block by the hash component of the BlockIdentifier, this request MUST be idempotent: repeated invocations for the same hash-identified block must return the exact same block contents. No such restriction is imposed when requesting a block by height, given that a chain reorg event might cause the specific block at height `n` to be set to a different one.
     * @summary Get a Block
     * @param {BlockRequest} blockRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockApi
     */
    public block(blockRequest: BlockRequest, options?: any) {
        return BlockApiFp(this.configuration).block(blockRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a transaction in a block by its Transaction Identifier. This endpoint should only be used when querying a node for a block does not return all transactions contained within it. All transactions returned by this endpoint must be appended to any transactions returned by the /block method by consumers of this data. Fetching a transaction by hash is considered an Explorer Method (which is classified under the Future Work section). This method can be used to let consumers to paginate results when the  block trasactions count is too big to be returned in a single BlockResponse. Calling this endpoint requires reference to a BlockIdentifier because transaction parsing can change depending on which block contains the transaction. For example, in Bitcoin it is necessary to know which block contains a transaction to determine the destination of fee payments. Without specifying a block identifier, the node would have to infer which block to use (which could change during a re-org). Implementations that require fetching previous transactions to populate the response (ex: Previous UTXOs in Bitcoin) may find it useful to run a cache within the Rosetta server in the /data directory (on a path that does not conflict with the node).
     * @summary Get a Block Transaction
     * @param {BlockTransactionRequest} blockTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockApi
     */
    public blockTransaction(blockTransactionRequest: BlockTransactionRequest, options?: any) {
        return BlockApiFp(this.configuration).blockTransaction(blockTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CallApi - axios parameter creator
 * @export
 */
export const CallApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Call invokes an arbitrary, network-specific procedure call with network-specific parameters. The guidance for what this endpoint should or could do is purposely left vague. In Ethereum, this could be used to invoke `eth_call` to implement an entire Rosetta API interface for some smart contract that is not parsed by the implementation creator (like a DEX). This endpoint could also be used to provide access to data that does not map to any Rosetta models instead of requiring an integrator to use some network-specific SDK and call some network-specific endpoint (like surfacing staking parameters). Call is NOT a replacement for implementing Rosetta API endpoints or mapping network-specific data to Rosetta models. Rather, it enables developers to build additional Rosetta API interfaces for things they care about without introducing complexity into a base-level Rosetta implementation. Simply put, imagine that the average integrator will use layered Rosetta API implementations that each surfaces unique data.
         * @summary Make a Network-Specific Procedure Call
         * @param {CallRequest} callRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        call: async (callRequest: CallRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'callRequest' is not null or undefined
            if (callRequest === null || callRequest === undefined) {
                throw new RequiredError('callRequest','Required parameter callRequest was null or undefined when calling call.');
            }
            const localVarPath = `/call`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof callRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(callRequest !== undefined ? callRequest : {})
                : (callRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CallApi - functional programming interface
 * @export
 */
export const CallApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Call invokes an arbitrary, network-specific procedure call with network-specific parameters. The guidance for what this endpoint should or could do is purposely left vague. In Ethereum, this could be used to invoke `eth_call` to implement an entire Rosetta API interface for some smart contract that is not parsed by the implementation creator (like a DEX). This endpoint could also be used to provide access to data that does not map to any Rosetta models instead of requiring an integrator to use some network-specific SDK and call some network-specific endpoint (like surfacing staking parameters). Call is NOT a replacement for implementing Rosetta API endpoints or mapping network-specific data to Rosetta models. Rather, it enables developers to build additional Rosetta API interfaces for things they care about without introducing complexity into a base-level Rosetta implementation. Simply put, imagine that the average integrator will use layered Rosetta API implementations that each surfaces unique data.
         * @summary Make a Network-Specific Procedure Call
         * @param {CallRequest} callRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async call(callRequest: CallRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CallResponse>> {
            const localVarAxiosArgs = await CallApiAxiosParamCreator(configuration).call(callRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * CallApi - factory interface
 * @export
 */
export const CallApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Call invokes an arbitrary, network-specific procedure call with network-specific parameters. The guidance for what this endpoint should or could do is purposely left vague. In Ethereum, this could be used to invoke `eth_call` to implement an entire Rosetta API interface for some smart contract that is not parsed by the implementation creator (like a DEX). This endpoint could also be used to provide access to data that does not map to any Rosetta models instead of requiring an integrator to use some network-specific SDK and call some network-specific endpoint (like surfacing staking parameters). Call is NOT a replacement for implementing Rosetta API endpoints or mapping network-specific data to Rosetta models. Rather, it enables developers to build additional Rosetta API interfaces for things they care about without introducing complexity into a base-level Rosetta implementation. Simply put, imagine that the average integrator will use layered Rosetta API implementations that each surfaces unique data.
         * @summary Make a Network-Specific Procedure Call
         * @param {CallRequest} callRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        call(callRequest: CallRequest, options?: any): AxiosPromise<CallResponse> {
            return CallApiFp(configuration).call(callRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CallApi - object-oriented interface
 * @export
 * @class CallApi
 * @extends {BaseAPI}
 */
export class CallApi extends BaseAPI {
    /**
     * Call invokes an arbitrary, network-specific procedure call with network-specific parameters. The guidance for what this endpoint should or could do is purposely left vague. In Ethereum, this could be used to invoke `eth_call` to implement an entire Rosetta API interface for some smart contract that is not parsed by the implementation creator (like a DEX). This endpoint could also be used to provide access to data that does not map to any Rosetta models instead of requiring an integrator to use some network-specific SDK and call some network-specific endpoint (like surfacing staking parameters). Call is NOT a replacement for implementing Rosetta API endpoints or mapping network-specific data to Rosetta models. Rather, it enables developers to build additional Rosetta API interfaces for things they care about without introducing complexity into a base-level Rosetta implementation. Simply put, imagine that the average integrator will use layered Rosetta API implementations that each surfaces unique data.
     * @summary Make a Network-Specific Procedure Call
     * @param {CallRequest} callRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CallApi
     */
    public call(callRequest: CallRequest, options?: any) {
        return CallApiFp(this.configuration).call(callRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ConstructionApi - axios parameter creator
 * @export
 */
export const ConstructionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Combine creates a network-specific transaction from an unsigned transaction and an array of provided signatures. The signed transaction returned from this method will be sent to the `/construction/submit` endpoint by the caller.
         * @summary Create Network Transaction from Signatures
         * @param {ConstructionCombineRequest} constructionCombineRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        constructionCombine: async (constructionCombineRequest: ConstructionCombineRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'constructionCombineRequest' is not null or undefined
            if (constructionCombineRequest === null || constructionCombineRequest === undefined) {
                throw new RequiredError('constructionCombineRequest','Required parameter constructionCombineRequest was null or undefined when calling constructionCombine.');
            }
            const localVarPath = `/construction/combine`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof constructionCombineRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(constructionCombineRequest !== undefined ? constructionCombineRequest : {})
                : (constructionCombineRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Derive returns the AccountIdentifier associated with a public key. Blockchains that require an on-chain action to create an account should not implement this method.
         * @summary Derive an AccountIdentifier from a PublicKey
         * @param {ConstructionDeriveRequest} constructionDeriveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        constructionDerive: async (constructionDeriveRequest: ConstructionDeriveRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'constructionDeriveRequest' is not null or undefined
            if (constructionDeriveRequest === null || constructionDeriveRequest === undefined) {
                throw new RequiredError('constructionDeriveRequest','Required parameter constructionDeriveRequest was null or undefined when calling constructionDerive.');
            }
            const localVarPath = `/construction/derive`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof constructionDeriveRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(constructionDeriveRequest !== undefined ? constructionDeriveRequest : {})
                : (constructionDeriveRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * TransactionHash returns the network-specific transaction hash for a signed transaction.
         * @summary Get the Hash of a Signed Transaction
         * @param {ConstructionHashRequest} constructionHashRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        constructionHash: async (constructionHashRequest: ConstructionHashRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'constructionHashRequest' is not null or undefined
            if (constructionHashRequest === null || constructionHashRequest === undefined) {
                throw new RequiredError('constructionHashRequest','Required parameter constructionHashRequest was null or undefined when calling constructionHash.');
            }
            const localVarPath = `/construction/hash`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof constructionHashRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(constructionHashRequest !== undefined ? constructionHashRequest : {})
                : (constructionHashRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get any information required to construct a transaction for a specific network. Metadata returned here could be a recent hash to use, an account sequence number, or even arbitrary chain state. The request used when calling this endpoint is created by calling `/construction/preprocess` in an offline environment. You should NEVER assume that the request sent to this endpoint will be created by the caller or populated with any custom parameters. This must occur in `/construction/preprocess`. It is important to clarify that this endpoint should not pre-construct any transactions for the client (this should happen in `/construction/payloads`). This endpoint is left purposely unstructured because of the wide scope of metadata that could be required.
         * @summary Get Metadata for Transaction Construction
         * @param {ConstructionMetadataRequest} constructionMetadataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        constructionMetadata: async (constructionMetadataRequest: ConstructionMetadataRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'constructionMetadataRequest' is not null or undefined
            if (constructionMetadataRequest === null || constructionMetadataRequest === undefined) {
                throw new RequiredError('constructionMetadataRequest','Required parameter constructionMetadataRequest was null or undefined when calling constructionMetadata.');
            }
            const localVarPath = `/construction/metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof constructionMetadataRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(constructionMetadataRequest !== undefined ? constructionMetadataRequest : {})
                : (constructionMetadataRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Parse is called on both unsigned and signed transactions to understand the intent of the formulated transaction. This is run as a sanity check before signing (after `/construction/payloads`) and before broadcast (after `/construction/combine`). 
         * @summary Parse a Transaction
         * @param {ConstructionParseRequest} constructionParseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        constructionParse: async (constructionParseRequest: ConstructionParseRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'constructionParseRequest' is not null or undefined
            if (constructionParseRequest === null || constructionParseRequest === undefined) {
                throw new RequiredError('constructionParseRequest','Required parameter constructionParseRequest was null or undefined when calling constructionParse.');
            }
            const localVarPath = `/construction/parse`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof constructionParseRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(constructionParseRequest !== undefined ? constructionParseRequest : {})
                : (constructionParseRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Payloads is called with an array of operations and the response from `/construction/metadata`. It returns an unsigned transaction blob and a collection of payloads that must be signed by particular AccountIdentifiers using a certain SignatureType. The array of operations provided in transaction construction often times can not specify all \"effects\" of a transaction (consider invoked transactions in Ethereum). However, they can deterministically specify the \"intent\" of the transaction, which is sufficient for construction. For this reason, parsing the corresponding transaction in the Data API (when it lands on chain) will contain a superset of whatever operations were provided during construction.
         * @summary Generate an Unsigned Transaction and Signing Payloads
         * @param {ConstructionPayloadsRequest} constructionPayloadsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        constructionPayloads: async (constructionPayloadsRequest: ConstructionPayloadsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'constructionPayloadsRequest' is not null or undefined
            if (constructionPayloadsRequest === null || constructionPayloadsRequest === undefined) {
                throw new RequiredError('constructionPayloadsRequest','Required parameter constructionPayloadsRequest was null or undefined when calling constructionPayloads.');
            }
            const localVarPath = `/construction/payloads`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof constructionPayloadsRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(constructionPayloadsRequest !== undefined ? constructionPayloadsRequest : {})
                : (constructionPayloadsRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Preprocess is called prior to `/construction/payloads` to construct a request for any metadata that is needed for transaction construction given (i.e. account nonce). The `options` object returned from this endpoint will be sent to the `/construction/metadata` endpoint UNMODIFIED by the caller (in an offline execution environment). If your Construction API implementation has configuration options, they MUST be specified in the `/construction/preprocess` request (in the `metadata` field).
         * @summary Create a Request to Fetch Metadata
         * @param {ConstructionPreprocessRequest} constructionPreprocessRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        constructionPreprocess: async (constructionPreprocessRequest: ConstructionPreprocessRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'constructionPreprocessRequest' is not null or undefined
            if (constructionPreprocessRequest === null || constructionPreprocessRequest === undefined) {
                throw new RequiredError('constructionPreprocessRequest','Required parameter constructionPreprocessRequest was null or undefined when calling constructionPreprocess.');
            }
            const localVarPath = `/construction/preprocess`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof constructionPreprocessRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(constructionPreprocessRequest !== undefined ? constructionPreprocessRequest : {})
                : (constructionPreprocessRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit a pre-signed transaction to the node. This call should not block on the transaction being included in a block. Rather, it should return immediately with an indication of whether or not the transaction was included in the mempool. The transaction submission response should only return a 200 status if the submitted transaction could be included in the mempool. Otherwise, it should return an error.
         * @summary Submit a Signed Transaction
         * @param {ConstructionSubmitRequest} constructionSubmitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        constructionSubmit: async (constructionSubmitRequest: ConstructionSubmitRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'constructionSubmitRequest' is not null or undefined
            if (constructionSubmitRequest === null || constructionSubmitRequest === undefined) {
                throw new RequiredError('constructionSubmitRequest','Required parameter constructionSubmitRequest was null or undefined when calling constructionSubmit.');
            }
            const localVarPath = `/construction/submit`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof constructionSubmitRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(constructionSubmitRequest !== undefined ? constructionSubmitRequest : {})
                : (constructionSubmitRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ConstructionApi - functional programming interface
 * @export
 */
export const ConstructionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Combine creates a network-specific transaction from an unsigned transaction and an array of provided signatures. The signed transaction returned from this method will be sent to the `/construction/submit` endpoint by the caller.
         * @summary Create Network Transaction from Signatures
         * @param {ConstructionCombineRequest} constructionCombineRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async constructionCombine(constructionCombineRequest: ConstructionCombineRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConstructionCombineResponse>> {
            const localVarAxiosArgs = await ConstructionApiAxiosParamCreator(configuration).constructionCombine(constructionCombineRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Derive returns the AccountIdentifier associated with a public key. Blockchains that require an on-chain action to create an account should not implement this method.
         * @summary Derive an AccountIdentifier from a PublicKey
         * @param {ConstructionDeriveRequest} constructionDeriveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async constructionDerive(constructionDeriveRequest: ConstructionDeriveRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConstructionDeriveResponse>> {
            const localVarAxiosArgs = await ConstructionApiAxiosParamCreator(configuration).constructionDerive(constructionDeriveRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * TransactionHash returns the network-specific transaction hash for a signed transaction.
         * @summary Get the Hash of a Signed Transaction
         * @param {ConstructionHashRequest} constructionHashRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async constructionHash(constructionHashRequest: ConstructionHashRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIdentifierResponse>> {
            const localVarAxiosArgs = await ConstructionApiAxiosParamCreator(configuration).constructionHash(constructionHashRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get any information required to construct a transaction for a specific network. Metadata returned here could be a recent hash to use, an account sequence number, or even arbitrary chain state. The request used when calling this endpoint is created by calling `/construction/preprocess` in an offline environment. You should NEVER assume that the request sent to this endpoint will be created by the caller or populated with any custom parameters. This must occur in `/construction/preprocess`. It is important to clarify that this endpoint should not pre-construct any transactions for the client (this should happen in `/construction/payloads`). This endpoint is left purposely unstructured because of the wide scope of metadata that could be required.
         * @summary Get Metadata for Transaction Construction
         * @param {ConstructionMetadataRequest} constructionMetadataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async constructionMetadata(constructionMetadataRequest: ConstructionMetadataRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConstructionMetadataResponse>> {
            const localVarAxiosArgs = await ConstructionApiAxiosParamCreator(configuration).constructionMetadata(constructionMetadataRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Parse is called on both unsigned and signed transactions to understand the intent of the formulated transaction. This is run as a sanity check before signing (after `/construction/payloads`) and before broadcast (after `/construction/combine`). 
         * @summary Parse a Transaction
         * @param {ConstructionParseRequest} constructionParseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async constructionParse(constructionParseRequest: ConstructionParseRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConstructionParseResponse>> {
            const localVarAxiosArgs = await ConstructionApiAxiosParamCreator(configuration).constructionParse(constructionParseRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Payloads is called with an array of operations and the response from `/construction/metadata`. It returns an unsigned transaction blob and a collection of payloads that must be signed by particular AccountIdentifiers using a certain SignatureType. The array of operations provided in transaction construction often times can not specify all \"effects\" of a transaction (consider invoked transactions in Ethereum). However, they can deterministically specify the \"intent\" of the transaction, which is sufficient for construction. For this reason, parsing the corresponding transaction in the Data API (when it lands on chain) will contain a superset of whatever operations were provided during construction.
         * @summary Generate an Unsigned Transaction and Signing Payloads
         * @param {ConstructionPayloadsRequest} constructionPayloadsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async constructionPayloads(constructionPayloadsRequest: ConstructionPayloadsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConstructionPayloadsResponse>> {
            const localVarAxiosArgs = await ConstructionApiAxiosParamCreator(configuration).constructionPayloads(constructionPayloadsRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Preprocess is called prior to `/construction/payloads` to construct a request for any metadata that is needed for transaction construction given (i.e. account nonce). The `options` object returned from this endpoint will be sent to the `/construction/metadata` endpoint UNMODIFIED by the caller (in an offline execution environment). If your Construction API implementation has configuration options, they MUST be specified in the `/construction/preprocess` request (in the `metadata` field).
         * @summary Create a Request to Fetch Metadata
         * @param {ConstructionPreprocessRequest} constructionPreprocessRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async constructionPreprocess(constructionPreprocessRequest: ConstructionPreprocessRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConstructionPreprocessResponse>> {
            const localVarAxiosArgs = await ConstructionApiAxiosParamCreator(configuration).constructionPreprocess(constructionPreprocessRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Submit a pre-signed transaction to the node. This call should not block on the transaction being included in a block. Rather, it should return immediately with an indication of whether or not the transaction was included in the mempool. The transaction submission response should only return a 200 status if the submitted transaction could be included in the mempool. Otherwise, it should return an error.
         * @summary Submit a Signed Transaction
         * @param {ConstructionSubmitRequest} constructionSubmitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async constructionSubmit(constructionSubmitRequest: ConstructionSubmitRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TransactionIdentifierResponse>> {
            const localVarAxiosArgs = await ConstructionApiAxiosParamCreator(configuration).constructionSubmit(constructionSubmitRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ConstructionApi - factory interface
 * @export
 */
export const ConstructionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Combine creates a network-specific transaction from an unsigned transaction and an array of provided signatures. The signed transaction returned from this method will be sent to the `/construction/submit` endpoint by the caller.
         * @summary Create Network Transaction from Signatures
         * @param {ConstructionCombineRequest} constructionCombineRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        constructionCombine(constructionCombineRequest: ConstructionCombineRequest, options?: any): AxiosPromise<ConstructionCombineResponse> {
            return ConstructionApiFp(configuration).constructionCombine(constructionCombineRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Derive returns the AccountIdentifier associated with a public key. Blockchains that require an on-chain action to create an account should not implement this method.
         * @summary Derive an AccountIdentifier from a PublicKey
         * @param {ConstructionDeriveRequest} constructionDeriveRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        constructionDerive(constructionDeriveRequest: ConstructionDeriveRequest, options?: any): AxiosPromise<ConstructionDeriveResponse> {
            return ConstructionApiFp(configuration).constructionDerive(constructionDeriveRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * TransactionHash returns the network-specific transaction hash for a signed transaction.
         * @summary Get the Hash of a Signed Transaction
         * @param {ConstructionHashRequest} constructionHashRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        constructionHash(constructionHashRequest: ConstructionHashRequest, options?: any): AxiosPromise<TransactionIdentifierResponse> {
            return ConstructionApiFp(configuration).constructionHash(constructionHashRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get any information required to construct a transaction for a specific network. Metadata returned here could be a recent hash to use, an account sequence number, or even arbitrary chain state. The request used when calling this endpoint is created by calling `/construction/preprocess` in an offline environment. You should NEVER assume that the request sent to this endpoint will be created by the caller or populated with any custom parameters. This must occur in `/construction/preprocess`. It is important to clarify that this endpoint should not pre-construct any transactions for the client (this should happen in `/construction/payloads`). This endpoint is left purposely unstructured because of the wide scope of metadata that could be required.
         * @summary Get Metadata for Transaction Construction
         * @param {ConstructionMetadataRequest} constructionMetadataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        constructionMetadata(constructionMetadataRequest: ConstructionMetadataRequest, options?: any): AxiosPromise<ConstructionMetadataResponse> {
            return ConstructionApiFp(configuration).constructionMetadata(constructionMetadataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Parse is called on both unsigned and signed transactions to understand the intent of the formulated transaction. This is run as a sanity check before signing (after `/construction/payloads`) and before broadcast (after `/construction/combine`). 
         * @summary Parse a Transaction
         * @param {ConstructionParseRequest} constructionParseRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        constructionParse(constructionParseRequest: ConstructionParseRequest, options?: any): AxiosPromise<ConstructionParseResponse> {
            return ConstructionApiFp(configuration).constructionParse(constructionParseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Payloads is called with an array of operations and the response from `/construction/metadata`. It returns an unsigned transaction blob and a collection of payloads that must be signed by particular AccountIdentifiers using a certain SignatureType. The array of operations provided in transaction construction often times can not specify all \"effects\" of a transaction (consider invoked transactions in Ethereum). However, they can deterministically specify the \"intent\" of the transaction, which is sufficient for construction. For this reason, parsing the corresponding transaction in the Data API (when it lands on chain) will contain a superset of whatever operations were provided during construction.
         * @summary Generate an Unsigned Transaction and Signing Payloads
         * @param {ConstructionPayloadsRequest} constructionPayloadsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        constructionPayloads(constructionPayloadsRequest: ConstructionPayloadsRequest, options?: any): AxiosPromise<ConstructionPayloadsResponse> {
            return ConstructionApiFp(configuration).constructionPayloads(constructionPayloadsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Preprocess is called prior to `/construction/payloads` to construct a request for any metadata that is needed for transaction construction given (i.e. account nonce). The `options` object returned from this endpoint will be sent to the `/construction/metadata` endpoint UNMODIFIED by the caller (in an offline execution environment). If your Construction API implementation has configuration options, they MUST be specified in the `/construction/preprocess` request (in the `metadata` field).
         * @summary Create a Request to Fetch Metadata
         * @param {ConstructionPreprocessRequest} constructionPreprocessRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        constructionPreprocess(constructionPreprocessRequest: ConstructionPreprocessRequest, options?: any): AxiosPromise<ConstructionPreprocessResponse> {
            return ConstructionApiFp(configuration).constructionPreprocess(constructionPreprocessRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit a pre-signed transaction to the node. This call should not block on the transaction being included in a block. Rather, it should return immediately with an indication of whether or not the transaction was included in the mempool. The transaction submission response should only return a 200 status if the submitted transaction could be included in the mempool. Otherwise, it should return an error.
         * @summary Submit a Signed Transaction
         * @param {ConstructionSubmitRequest} constructionSubmitRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        constructionSubmit(constructionSubmitRequest: ConstructionSubmitRequest, options?: any): AxiosPromise<TransactionIdentifierResponse> {
            return ConstructionApiFp(configuration).constructionSubmit(constructionSubmitRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ConstructionApi - object-oriented interface
 * @export
 * @class ConstructionApi
 * @extends {BaseAPI}
 */
export class ConstructionApi extends BaseAPI {
    /**
     * Combine creates a network-specific transaction from an unsigned transaction and an array of provided signatures. The signed transaction returned from this method will be sent to the `/construction/submit` endpoint by the caller.
     * @summary Create Network Transaction from Signatures
     * @param {ConstructionCombineRequest} constructionCombineRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConstructionApi
     */
    public constructionCombine(constructionCombineRequest: ConstructionCombineRequest, options?: any) {
        return ConstructionApiFp(this.configuration).constructionCombine(constructionCombineRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Derive returns the AccountIdentifier associated with a public key. Blockchains that require an on-chain action to create an account should not implement this method.
     * @summary Derive an AccountIdentifier from a PublicKey
     * @param {ConstructionDeriveRequest} constructionDeriveRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConstructionApi
     */
    public constructionDerive(constructionDeriveRequest: ConstructionDeriveRequest, options?: any) {
        return ConstructionApiFp(this.configuration).constructionDerive(constructionDeriveRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * TransactionHash returns the network-specific transaction hash for a signed transaction.
     * @summary Get the Hash of a Signed Transaction
     * @param {ConstructionHashRequest} constructionHashRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConstructionApi
     */
    public constructionHash(constructionHashRequest: ConstructionHashRequest, options?: any) {
        return ConstructionApiFp(this.configuration).constructionHash(constructionHashRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get any information required to construct a transaction for a specific network. Metadata returned here could be a recent hash to use, an account sequence number, or even arbitrary chain state. The request used when calling this endpoint is created by calling `/construction/preprocess` in an offline environment. You should NEVER assume that the request sent to this endpoint will be created by the caller or populated with any custom parameters. This must occur in `/construction/preprocess`. It is important to clarify that this endpoint should not pre-construct any transactions for the client (this should happen in `/construction/payloads`). This endpoint is left purposely unstructured because of the wide scope of metadata that could be required.
     * @summary Get Metadata for Transaction Construction
     * @param {ConstructionMetadataRequest} constructionMetadataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConstructionApi
     */
    public constructionMetadata(constructionMetadataRequest: ConstructionMetadataRequest, options?: any) {
        return ConstructionApiFp(this.configuration).constructionMetadata(constructionMetadataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Parse is called on both unsigned and signed transactions to understand the intent of the formulated transaction. This is run as a sanity check before signing (after `/construction/payloads`) and before broadcast (after `/construction/combine`). 
     * @summary Parse a Transaction
     * @param {ConstructionParseRequest} constructionParseRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConstructionApi
     */
    public constructionParse(constructionParseRequest: ConstructionParseRequest, options?: any) {
        return ConstructionApiFp(this.configuration).constructionParse(constructionParseRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Payloads is called with an array of operations and the response from `/construction/metadata`. It returns an unsigned transaction blob and a collection of payloads that must be signed by particular AccountIdentifiers using a certain SignatureType. The array of operations provided in transaction construction often times can not specify all \"effects\" of a transaction (consider invoked transactions in Ethereum). However, they can deterministically specify the \"intent\" of the transaction, which is sufficient for construction. For this reason, parsing the corresponding transaction in the Data API (when it lands on chain) will contain a superset of whatever operations were provided during construction.
     * @summary Generate an Unsigned Transaction and Signing Payloads
     * @param {ConstructionPayloadsRequest} constructionPayloadsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConstructionApi
     */
    public constructionPayloads(constructionPayloadsRequest: ConstructionPayloadsRequest, options?: any) {
        return ConstructionApiFp(this.configuration).constructionPayloads(constructionPayloadsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Preprocess is called prior to `/construction/payloads` to construct a request for any metadata that is needed for transaction construction given (i.e. account nonce). The `options` object returned from this endpoint will be sent to the `/construction/metadata` endpoint UNMODIFIED by the caller (in an offline execution environment). If your Construction API implementation has configuration options, they MUST be specified in the `/construction/preprocess` request (in the `metadata` field).
     * @summary Create a Request to Fetch Metadata
     * @param {ConstructionPreprocessRequest} constructionPreprocessRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConstructionApi
     */
    public constructionPreprocess(constructionPreprocessRequest: ConstructionPreprocessRequest, options?: any) {
        return ConstructionApiFp(this.configuration).constructionPreprocess(constructionPreprocessRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit a pre-signed transaction to the node. This call should not block on the transaction being included in a block. Rather, it should return immediately with an indication of whether or not the transaction was included in the mempool. The transaction submission response should only return a 200 status if the submitted transaction could be included in the mempool. Otherwise, it should return an error.
     * @summary Submit a Signed Transaction
     * @param {ConstructionSubmitRequest} constructionSubmitRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ConstructionApi
     */
    public constructionSubmit(constructionSubmitRequest: ConstructionSubmitRequest, options?: any) {
        return ConstructionApiFp(this.configuration).constructionSubmit(constructionSubmitRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * EventsApi - axios parameter creator
 * @export
 */
export const EventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * `/events/blocks` allows the caller to query a sequence of BlockEvents indicating which blocks were added and removed from storage to reach the current state. Following BlockEvents allows lightweight clients to update their state without needing to implement their own syncing logic (like finding the common parent in a reorg). `/events/blocks` is considered an \"indexer\" endpoint and Rosetta implementations are not required to complete it to adhere to the Rosetta spec. However, any Rosetta \"indexer\" MUST support this endpoint.
         * @summary [INDEXER] Get a range of BlockEvents
         * @param {EventsBlocksRequest} eventsBlocksRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsBlocks: async (eventsBlocksRequest: EventsBlocksRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'eventsBlocksRequest' is not null or undefined
            if (eventsBlocksRequest === null || eventsBlocksRequest === undefined) {
                throw new RequiredError('eventsBlocksRequest','Required parameter eventsBlocksRequest was null or undefined when calling eventsBlocks.');
            }
            const localVarPath = `/events/blocks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof eventsBlocksRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(eventsBlocksRequest !== undefined ? eventsBlocksRequest : {})
                : (eventsBlocksRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EventsApi - functional programming interface
 * @export
 */
export const EventsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * `/events/blocks` allows the caller to query a sequence of BlockEvents indicating which blocks were added and removed from storage to reach the current state. Following BlockEvents allows lightweight clients to update their state without needing to implement their own syncing logic (like finding the common parent in a reorg). `/events/blocks` is considered an \"indexer\" endpoint and Rosetta implementations are not required to complete it to adhere to the Rosetta spec. However, any Rosetta \"indexer\" MUST support this endpoint.
         * @summary [INDEXER] Get a range of BlockEvents
         * @param {EventsBlocksRequest} eventsBlocksRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async eventsBlocks(eventsBlocksRequest: EventsBlocksRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EventsBlocksResponse>> {
            const localVarAxiosArgs = await EventsApiAxiosParamCreator(configuration).eventsBlocks(eventsBlocksRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * EventsApi - factory interface
 * @export
 */
export const EventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * `/events/blocks` allows the caller to query a sequence of BlockEvents indicating which blocks were added and removed from storage to reach the current state. Following BlockEvents allows lightweight clients to update their state without needing to implement their own syncing logic (like finding the common parent in a reorg). `/events/blocks` is considered an \"indexer\" endpoint and Rosetta implementations are not required to complete it to adhere to the Rosetta spec. However, any Rosetta \"indexer\" MUST support this endpoint.
         * @summary [INDEXER] Get a range of BlockEvents
         * @param {EventsBlocksRequest} eventsBlocksRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        eventsBlocks(eventsBlocksRequest: EventsBlocksRequest, options?: any): AxiosPromise<EventsBlocksResponse> {
            return EventsApiFp(configuration).eventsBlocks(eventsBlocksRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EventsApi - object-oriented interface
 * @export
 * @class EventsApi
 * @extends {BaseAPI}
 */
export class EventsApi extends BaseAPI {
    /**
     * `/events/blocks` allows the caller to query a sequence of BlockEvents indicating which blocks were added and removed from storage to reach the current state. Following BlockEvents allows lightweight clients to update their state without needing to implement their own syncing logic (like finding the common parent in a reorg). `/events/blocks` is considered an \"indexer\" endpoint and Rosetta implementations are not required to complete it to adhere to the Rosetta spec. However, any Rosetta \"indexer\" MUST support this endpoint.
     * @summary [INDEXER] Get a range of BlockEvents
     * @param {EventsBlocksRequest} eventsBlocksRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EventsApi
     */
    public eventsBlocks(eventsBlocksRequest: EventsBlocksRequest, options?: any) {
        return EventsApiFp(this.configuration).eventsBlocks(eventsBlocksRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * MempoolApi - axios parameter creator
 * @export
 */
export const MempoolApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get all Transaction Identifiers in the mempool
         * @summary Get All Mempool Transactions
         * @param {NetworkRequest} networkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mempool: async (networkRequest: NetworkRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkRequest' is not null or undefined
            if (networkRequest === null || networkRequest === undefined) {
                throw new RequiredError('networkRequest','Required parameter networkRequest was null or undefined when calling mempool.');
            }
            const localVarPath = `/mempool`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof networkRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(networkRequest !== undefined ? networkRequest : {})
                : (networkRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a transaction in the mempool by its Transaction Identifier. This is a separate request than fetching a block transaction (/block/transaction) because some blockchain nodes need to know that a transaction query is for something in the mempool instead of a transaction in a block. Transactions may not be fully parsable until they are in a block (ex: may not be possible to determine the fee to pay before a transaction is executed). On this endpoint, it is ok that returned transactions are only estimates of what may actually be included in a block.
         * @summary Get a Mempool Transaction
         * @param {MempoolTransactionRequest} mempoolTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mempoolTransaction: async (mempoolTransactionRequest: MempoolTransactionRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'mempoolTransactionRequest' is not null or undefined
            if (mempoolTransactionRequest === null || mempoolTransactionRequest === undefined) {
                throw new RequiredError('mempoolTransactionRequest','Required parameter mempoolTransactionRequest was null or undefined when calling mempoolTransaction.');
            }
            const localVarPath = `/mempool/transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof mempoolTransactionRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(mempoolTransactionRequest !== undefined ? mempoolTransactionRequest : {})
                : (mempoolTransactionRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MempoolApi - functional programming interface
 * @export
 */
export const MempoolApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get all Transaction Identifiers in the mempool
         * @summary Get All Mempool Transactions
         * @param {NetworkRequest} networkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mempool(networkRequest: NetworkRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MempoolResponse>> {
            const localVarAxiosArgs = await MempoolApiAxiosParamCreator(configuration).mempool(networkRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get a transaction in the mempool by its Transaction Identifier. This is a separate request than fetching a block transaction (/block/transaction) because some blockchain nodes need to know that a transaction query is for something in the mempool instead of a transaction in a block. Transactions may not be fully parsable until they are in a block (ex: may not be possible to determine the fee to pay before a transaction is executed). On this endpoint, it is ok that returned transactions are only estimates of what may actually be included in a block.
         * @summary Get a Mempool Transaction
         * @param {MempoolTransactionRequest} mempoolTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async mempoolTransaction(mempoolTransactionRequest: MempoolTransactionRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MempoolTransactionResponse>> {
            const localVarAxiosArgs = await MempoolApiAxiosParamCreator(configuration).mempoolTransaction(mempoolTransactionRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * MempoolApi - factory interface
 * @export
 */
export const MempoolApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get all Transaction Identifiers in the mempool
         * @summary Get All Mempool Transactions
         * @param {NetworkRequest} networkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mempool(networkRequest: NetworkRequest, options?: any): AxiosPromise<MempoolResponse> {
            return MempoolApiFp(configuration).mempool(networkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a transaction in the mempool by its Transaction Identifier. This is a separate request than fetching a block transaction (/block/transaction) because some blockchain nodes need to know that a transaction query is for something in the mempool instead of a transaction in a block. Transactions may not be fully parsable until they are in a block (ex: may not be possible to determine the fee to pay before a transaction is executed). On this endpoint, it is ok that returned transactions are only estimates of what may actually be included in a block.
         * @summary Get a Mempool Transaction
         * @param {MempoolTransactionRequest} mempoolTransactionRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        mempoolTransaction(mempoolTransactionRequest: MempoolTransactionRequest, options?: any): AxiosPromise<MempoolTransactionResponse> {
            return MempoolApiFp(configuration).mempoolTransaction(mempoolTransactionRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MempoolApi - object-oriented interface
 * @export
 * @class MempoolApi
 * @extends {BaseAPI}
 */
export class MempoolApi extends BaseAPI {
    /**
     * Get all Transaction Identifiers in the mempool
     * @summary Get All Mempool Transactions
     * @param {NetworkRequest} networkRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MempoolApi
     */
    public mempool(networkRequest: NetworkRequest, options?: any) {
        return MempoolApiFp(this.configuration).mempool(networkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a transaction in the mempool by its Transaction Identifier. This is a separate request than fetching a block transaction (/block/transaction) because some blockchain nodes need to know that a transaction query is for something in the mempool instead of a transaction in a block. Transactions may not be fully parsable until they are in a block (ex: may not be possible to determine the fee to pay before a transaction is executed). On this endpoint, it is ok that returned transactions are only estimates of what may actually be included in a block.
     * @summary Get a Mempool Transaction
     * @param {MempoolTransactionRequest} mempoolTransactionRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MempoolApi
     */
    public mempoolTransaction(mempoolTransactionRequest: MempoolTransactionRequest, options?: any) {
        return MempoolApiFp(this.configuration).mempoolTransaction(mempoolTransactionRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NetworkApi - axios parameter creator
 * @export
 */
export const NetworkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This endpoint returns a list of NetworkIdentifiers that the Rosetta server supports.
         * @summary Get List of Available Networks
         * @param {MetadataRequest} metadataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkList: async (metadataRequest: MetadataRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'metadataRequest' is not null or undefined
            if (metadataRequest === null || metadataRequest === undefined) {
                throw new RequiredError('metadataRequest','Required parameter metadataRequest was null or undefined when calling networkList.');
            }
            const localVarPath = `/network/list`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof metadataRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(metadataRequest !== undefined ? metadataRequest : {})
                : (metadataRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns the version information and allowed network-specific types for a NetworkIdentifier. Any NetworkIdentifier returned by /network/list should be accessible here. Because options are retrievable in the context of a NetworkIdentifier, it is possible to define unique options for each network.
         * @summary Get Network Options
         * @param {NetworkRequest} networkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkOptions: async (networkRequest: NetworkRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkRequest' is not null or undefined
            if (networkRequest === null || networkRequest === undefined) {
                throw new RequiredError('networkRequest','Required parameter networkRequest was null or undefined when calling networkOptions.');
            }
            const localVarPath = `/network/options`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof networkRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(networkRequest !== undefined ? networkRequest : {})
                : (networkRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * This endpoint returns the current status of the network requested. Any NetworkIdentifier returned by /network/list should be accessible here.
         * @summary Get Network Status
         * @param {NetworkRequest} networkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkStatus: async (networkRequest: NetworkRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkRequest' is not null or undefined
            if (networkRequest === null || networkRequest === undefined) {
                throw new RequiredError('networkRequest','Required parameter networkRequest was null or undefined when calling networkStatus.');
            }
            const localVarPath = `/network/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof networkRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(networkRequest !== undefined ? networkRequest : {})
                : (networkRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NetworkApi - functional programming interface
 * @export
 */
export const NetworkApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This endpoint returns a list of NetworkIdentifiers that the Rosetta server supports.
         * @summary Get List of Available Networks
         * @param {MetadataRequest} metadataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkList(metadataRequest: MetadataRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkListResponse>> {
            const localVarAxiosArgs = await NetworkApiAxiosParamCreator(configuration).networkList(metadataRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This endpoint returns the version information and allowed network-specific types for a NetworkIdentifier. Any NetworkIdentifier returned by /network/list should be accessible here. Because options are retrievable in the context of a NetworkIdentifier, it is possible to define unique options for each network.
         * @summary Get Network Options
         * @param {NetworkRequest} networkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkOptions(networkRequest: NetworkRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkOptionsResponse>> {
            const localVarAxiosArgs = await NetworkApiAxiosParamCreator(configuration).networkOptions(networkRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * This endpoint returns the current status of the network requested. Any NetworkIdentifier returned by /network/list should be accessible here.
         * @summary Get Network Status
         * @param {NetworkRequest} networkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkStatus(networkRequest: NetworkRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkStatusResponse>> {
            const localVarAxiosArgs = await NetworkApiAxiosParamCreator(configuration).networkStatus(networkRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * NetworkApi - factory interface
 * @export
 */
export const NetworkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * This endpoint returns a list of NetworkIdentifiers that the Rosetta server supports.
         * @summary Get List of Available Networks
         * @param {MetadataRequest} metadataRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkList(metadataRequest: MetadataRequest, options?: any): AxiosPromise<NetworkListResponse> {
            return NetworkApiFp(configuration).networkList(metadataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns the version information and allowed network-specific types for a NetworkIdentifier. Any NetworkIdentifier returned by /network/list should be accessible here. Because options are retrievable in the context of a NetworkIdentifier, it is possible to define unique options for each network.
         * @summary Get Network Options
         * @param {NetworkRequest} networkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkOptions(networkRequest: NetworkRequest, options?: any): AxiosPromise<NetworkOptionsResponse> {
            return NetworkApiFp(configuration).networkOptions(networkRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * This endpoint returns the current status of the network requested. Any NetworkIdentifier returned by /network/list should be accessible here.
         * @summary Get Network Status
         * @param {NetworkRequest} networkRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkStatus(networkRequest: NetworkRequest, options?: any): AxiosPromise<NetworkStatusResponse> {
            return NetworkApiFp(configuration).networkStatus(networkRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NetworkApi - object-oriented interface
 * @export
 * @class NetworkApi
 * @extends {BaseAPI}
 */
export class NetworkApi extends BaseAPI {
    /**
     * This endpoint returns a list of NetworkIdentifiers that the Rosetta server supports.
     * @summary Get List of Available Networks
     * @param {MetadataRequest} metadataRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public networkList(metadataRequest: MetadataRequest, options?: any) {
        return NetworkApiFp(this.configuration).networkList(metadataRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns the version information and allowed network-specific types for a NetworkIdentifier. Any NetworkIdentifier returned by /network/list should be accessible here. Because options are retrievable in the context of a NetworkIdentifier, it is possible to define unique options for each network.
     * @summary Get Network Options
     * @param {NetworkRequest} networkRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public networkOptions(networkRequest: NetworkRequest, options?: any) {
        return NetworkApiFp(this.configuration).networkOptions(networkRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This endpoint returns the current status of the network requested. Any NetworkIdentifier returned by /network/list should be accessible here.
     * @summary Get Network Status
     * @param {NetworkRequest} networkRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public networkStatus(networkRequest: NetworkRequest, options?: any) {
        return NetworkApiFp(this.configuration).networkStatus(networkRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SearchApi - axios parameter creator
 * @export
 */
export const SearchApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * `/search/transactions` allows the caller to search for transactions that meet certain conditions. Some conditions include matching a transaction hash, containing an operation with a certain status, or containing an operation that affects a certain account. `/search/transactions` is considered an \"indexer\" endpoint and Rosetta implementations are not required to complete it to adhere to the Rosetta spec. However, any Rosetta \"indexer\" MUST support this endpoint.
         * @summary [INDEXER] Search for Transactions
         * @param {SearchTransactionsRequest} searchTransactionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTransactions: async (searchTransactionsRequest: SearchTransactionsRequest, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchTransactionsRequest' is not null or undefined
            if (searchTransactionsRequest === null || searchTransactionsRequest === undefined) {
                throw new RequiredError('searchTransactionsRequest','Required parameter searchTransactionsRequest was null or undefined when calling searchTransactions.');
            }
            const localVarPath = `/search/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const nonString = typeof searchTransactionsRequest !== 'string';
            const needsSerialization = nonString && configuration && configuration.isJsonMime
                ? configuration.isJsonMime(localVarRequestOptions.headers['Content-Type'])
                : nonString;
            localVarRequestOptions.data =  needsSerialization
                ? JSON.stringify(searchTransactionsRequest !== undefined ? searchTransactionsRequest : {})
                : (searchTransactionsRequest || "");

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    return {
        /**
         * `/search/transactions` allows the caller to search for transactions that meet certain conditions. Some conditions include matching a transaction hash, containing an operation with a certain status, or containing an operation that affects a certain account. `/search/transactions` is considered an \"indexer\" endpoint and Rosetta implementations are not required to complete it to adhere to the Rosetta spec. However, any Rosetta \"indexer\" MUST support this endpoint.
         * @summary [INDEXER] Search for Transactions
         * @param {SearchTransactionsRequest} searchTransactionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchTransactions(searchTransactionsRequest: SearchTransactionsRequest, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchTransactionsResponse>> {
            const localVarAxiosArgs = await SearchApiAxiosParamCreator(configuration).searchTransactions(searchTransactionsRequest, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * `/search/transactions` allows the caller to search for transactions that meet certain conditions. Some conditions include matching a transaction hash, containing an operation with a certain status, or containing an operation that affects a certain account. `/search/transactions` is considered an \"indexer\" endpoint and Rosetta implementations are not required to complete it to adhere to the Rosetta spec. However, any Rosetta \"indexer\" MUST support this endpoint.
         * @summary [INDEXER] Search for Transactions
         * @param {SearchTransactionsRequest} searchTransactionsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchTransactions(searchTransactionsRequest: SearchTransactionsRequest, options?: any): AxiosPromise<SearchTransactionsResponse> {
            return SearchApiFp(configuration).searchTransactions(searchTransactionsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * `/search/transactions` allows the caller to search for transactions that meet certain conditions. Some conditions include matching a transaction hash, containing an operation with a certain status, or containing an operation that affects a certain account. `/search/transactions` is considered an \"indexer\" endpoint and Rosetta implementations are not required to complete it to adhere to the Rosetta spec. However, any Rosetta \"indexer\" MUST support this endpoint.
     * @summary [INDEXER] Search for Transactions
     * @param {SearchTransactionsRequest} searchTransactionsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public searchTransactions(searchTransactionsRequest: SearchTransactionsRequest, options?: any) {
        return SearchApiFp(this.configuration).searchTransactions(searchTransactionsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


